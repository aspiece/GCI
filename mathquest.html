<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CS Math Quest — Catch‑Up Arcade</title>
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121935;
      --panel2: #0e1530;
      --acc: #6cf;
      --acc2: #9f6cff;
      --good: #2ecc71;
      --bad: #e74c3c;
      --text: #e6ecff;
      --muted: #9fb0d7;
    }

    /* THEMES */
    [data-theme="space"] {
      --bg: #0a0f1f;
      --panel: #111936;
      --panel2: #0c1430;
      --acc: #60a5fa;
      /* blue-400 */
      --acc2: #a78bfa;
      /* violet-400 */
      --good: #22c55e;
      /* green-500 */
      --bad: #ef4444;
      /* red-500 */
      --text: #f8fafc;
      /* slate-50 */
      --muted: #cbd5e1;
      /* slate-300 */
    }

    [data-theme="ice"] {
      --bg: #0a1326;
      --panel: #0e1a3d;
      --panel2: #0a1f4a;
      --acc: #7dd3fc;
      /* sky-300 */
      --acc2: #c7d2fe;
      /* indigo-200 */
      --good: #34d399;
      /* emerald-400 */
      --bad: #f87171;
      /* red-400 */
      --text: #f1f5f9;
      /* slate-100 */
      --muted: #d1e9ff;
      /* light cyan */
    }

    [data-theme="jungle"] {
      --bg: #0a140c;
      --panel: #0e2616;
      --panel2: #0a331f;
      --acc: #86efac;
      /* green-300 */
      --acc2: #4ade80;
      /* green-400 */
      --good: #16a34a;
      /* green-600 */
      --bad: #f97316;
      /* orange-500 for better CB distinction */
      --text: #ecfdf5;
      /* emerald-50 */
      --muted: #b7e4c7;
      /* mint */
    }

    [data-theme="dungeon"] {
      --bg: #0e0c09;
      --panel: #171208;
      --panel2: #241a0b;
      --acc: #fbbf24;
      /* amber-400 */
      --acc2: #f59e0b;
      /* amber-500 */
      --good: #22c55e;
      /* green-500 */
      --bad: #ef4444;
      /* red-500 */
      --text: #fff7ed;
      /* orange-50 */
      --muted: #f5deb3;
      /* warm sand */
    }

    [data-theme="workshop"] {
      --bg: #140f0a;
      --panel: #1b140e;
      --panel2: #231a12;
      --acc: #f59e0b;
      /* amber-500 */
      --acc2: #f97316;
      /* orange-500 */
      --good: #22c55e;
      /* green-500 */
      --bad: #ef4444;
      /* red-500 */
      --text: #fff1e6;
      --muted: #e2c8b5;
    }

    [data-theme="portal"] {
      --bg: #130a19;
      --panel: #1b1030;
      --panel2: #2b1550;
      --acc: #a78bfa;
      /* violet-400 */
      --acc2: #f472b6;
      /* pink-400 */
      --good: #10b981;
      /* emerald-500 */
      --bad: #f43f5e;
      /* rose-500 */
      --text: #f5f3ff;
      /* violet-50 */
      --muted: #d6bcfa;
      /* violet-200 */
    }

    /* Improve meter contrast */
    .meter>span {
      background: linear-gradient(90deg, #16a34a, #2563eb);
      /* green-600 → blue-600 */
    }

    /* Stronger focus outline for clarity */
    :focus-visible {
      outline: 3px solid var(--acc);
      outline-offset: 3px;
    }

    * {
      box-sizing: border-box
    }

    body {
      margin: 0;
      background: radial-gradient(1000px 600px at 80% -10%, #1e2c6f22 0, transparent 60%), radial-gradient(1200px 800px at -10% 110%, #9f6cff14 0, transparent 70%), var(--bg);
      color: var(--text);
      font: 16px/1.4 system-ui, Segoe UI, Roboto, Inter, sans-serif
    }

    .app {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 100vh
    }

    header {
      grid-column: 1/-1;
      background: linear-gradient(90deg, var(--panel2), #1a2555);
      padding: 14px 18px;
      border-bottom: 1px solid #263164;
      display: flex;
      align-items: center;
      gap: 16px
    }

    header h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: .4px
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #0b1230;
      border: 1px solid #2a3672;
      padding: 6px 10px;
      border-radius: 10px
    }

    .stat b {
      color: #fff
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-left: auto
    }

    .side {
      background: linear-gradient(180deg, var(--panel), #0c1433);
      border-right: 1px solid #28346e;
      padding: 12px
    }

    .sectionTitle {
      margin: 10px 0 6px;
      color: #bcd3ff;
      font-weight: 700;
      text-transform: uppercase;
      font-size: 12px;
      letter-spacing: 1.4px
    }

    .navBtn {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #2a3672;
      background: #0b1230;
      color: #e6ecff;
      cursor: pointer;
      margin: 6px 0;
      transition: .15s
    }

    .navBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px #0005
    }

    .navBtn.active {
      outline: 2px solid var(--acc)
    }

    .progress {
      height: 6px;
      background: #19224b;
      border-radius: 999px;
      overflow: hidden
    }

    .progress>span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, var(--acc), var(--acc2));
      width: 0%
    }

    main {
      padding: 18px 18px 48px
    }

    .card {
      background: linear-gradient(180deg, var(--panel), #0f1738);
      border: 1px solid #2b3a78;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px #0006
    }

    .grid {
      display: grid;
      gap: 16px
    }

    @media(min-width:980px) {
      .grid {
        grid-template-columns: 1.1fr .9fr
      }
    }

    h2 {
      margin: 4px 0 12px
    }

    .question {
      font-size: 22px;
      letter-spacing: .2px
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
    }

    .pill {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #34448a;
      background: #0b1230;
      color: #bcd3ff;
      font-size: 12px
    }

    input[type=number],
    input[type=text] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #2c3a77;
      background: #0d1433;
      color: #e6ecff
    }

    .btn {
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid #2c3a77;
      background: linear-gradient(180deg, #1a2555, #0d1433);
      color: #fff;
      cursor: pointer
    }

    .btn:hover {
      filter: brightness(1.08)
    }

    .btn.ghost {
      background: #0b1230
    }

    .feedback {
      margin-top: 10px;
      font-weight: 700
    }

    .good {
      color: var(--good)
    }

    .bad {
      color: var(--bad)
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: #151e44;
      border: 1px solid #2a3672;
      border-radius: 12px;
      padding: 6px 10px;
      margin: 4px 6px 0 0
    }

    .tiny {
      font-size: 12px;
      color: var(--muted)
    }

    .hint {
      margin-top: 10px;
      color: #ffd980
    }

    .kbd {
      border: 1px solid #2a3672;
      border-bottom-width: 3px;
      border-radius: 8px;
      padding: 2px 6px;
      background: #0b1230
    }

    .flex {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap
    }

    .right {
      margin-left: auto
    }

    .footer {
      opacity: .8;
      font-size: 12px;
      margin-top: 8px
    }

    /* FX canvas behind content */
    #fx {
      position: fixed;
      inset: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 0;
    }

    /* ensure UI sits above FX */
    header,
    .app {
      position: relative;
      z-index: 1;
    }

    /* Mastery glow */
    .pill.mastered {
      color: #ffd76a;
      border-color: #ffcf67;
      box-shadow: 0 0 12px #ffcf6755, inset 0 0 8px #ffcf6722;
      background: linear-gradient(180deg, #1d1a08, #0f0b02);
    }

    /* Subtle hover lift */
    .btn:hover {
      box-shadow: 0 6px 16px #0007;
      transform: translateY(-1px);
    }

    /* Symbol legend */
    .legend-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px 12px;
      margin-top: 8px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .legend-sym {
      min-width: 44px;
      text-align: center;
      font-size: 20px;
      padding: 4px 8px;
      border: 1px solid #2a3672;
      border-radius: 10px;
      background: #0b1230;
      color: #e6ecff;
    }

    .legend-note {
      font-size: 12px;
      color: var(--muted);
    }

    /* Engagement UI */
    .meter {
      height: 8px;
      background: #19224b;
      border-radius: 999px;
      overflow: hidden;
    }

    .meter>span {
      display: block;
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #2ecc71, #6cf);
      transition: width .3s;
    }

    .challenge {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 8px;
      border: 1px solid #2a3672;
      border-radius: 10px;
      background: #0b1230;
    }

    .challenge.done {
      opacity: .7;
      filter: saturate(.7);
    }

    .challenge .prog {
      margin-left: auto;
      font-size: 12px;
      color: var(--muted);
    }

    .challenge .check {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      border: 1px solid #2a3672;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: #0d1433;
      color: #2ecc71;
    }

    .stats-row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      margin: 6px 0;
    }

    .stats-row .pill {
      min-width: 140px;
      text-align: center;
    }

    .muted {
      color: var(--muted);
    }

    /* Accessibility helpers */
    .sr-only {
      position: absolute !important;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0 0 0 0);
      white-space: nowrap;
      border: 0;
    }

    .skip-link {
      position: absolute;
      left: 8px;
      top: -40px;
      z-index: 2;
      background: #151e44;
      color: #fff;
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #2a3672;
      transition: top .2s;
    }

    .skip-link:focus {
      top: 8px;
    }

    /* Quest Picker modal */
    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #0009;
      z-index: 3;
      padding: 16px;
    }

    .modal.show {
      display: flex;
    }

    .modal .dialog {
      width: min(720px, 96vw);
      background: linear-gradient(180deg, var(--panel), #0f1738);
      border: 1px solid #2b3a78;
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 10px 30px #000c;
    }

    .qp-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }

    .qp-btn {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #2a3672;
      background: #0b1230;
      color: #e6ecff;
      cursor: pointer;
    }

    .qp-btn .tiny {
      color: var(--muted);
    }

    /* Question correct pulse */
    .qPulse {
      animation: qpulse .6s ease-out;
    }

    @keyframes qpulse {
      0% {
        box-shadow: 0 0 0 0 rgba(34, 197, 94, .45);
      }

      100% {
        box-shadow: 0 0 0 22px rgba(34, 197, 94, 0);
      }
    }

    /* XP floaters */
    .xp-floater {
      position: fixed;
      z-index: 9999;
      pointer-events: none;
      font-weight: 700;
      color: #ffd76a;
      text-shadow: 0 2px 8px #0008;
      transform: translate(-50%, 0);
      animation: floatUp .85s ease-out forwards;
    }

    .xp-floater.neg {
      color: #f87171;
    }

    @keyframes floatUp {
      to {
        transform: translate(-50%, -28px);
        opacity: 0;
      }
    }

    /* Progress bar bump glow on increase */
    .progress>span.bump {
      animation: barBump .6s ease-out;
    }

    @keyframes barBump {
      0% {
        filter: brightness(1.3);
        box-shadow: 0 0 0 0 var(--acc);
      }

      100% {
        filter: none;
        box-shadow: 0 0 0 16px transparent;
      }
    }
  </style>
</head>

<body>
  <a href="#main" class="skip-link">Skip to main content</a>
  <canvas id="fx" aria-hidden="true"></canvas>
  <header>
    <h1>🕹️ CS Math Quest</h1>
    <div class="row">
      <div class="stat" title="Experience Points"><span>⭐</span> <span>XP:</span> <b id="xp">0</b></div>
      <div class="stat" title="Streak"><span>🔥</span> <span>Streak:</span> <b id="streak">0</b></div>
      <div class="stat" title="Rank"><span>🏆</span> <span>Rank:</span> <b id="rank">Novice</b></div>
      <label for="themeSelect" class="sr-only">Theme</label>
      <select id="themeSelect" class="btn ghost" title="Theme">
        <option value="auto">Auto (by Quest)</option>
        <option value="space">Space</option>
        <option value="ice">Ice Caves</option>
        <option value="jungle">Jungle</option>
        <option value="dungeon">Temple</option>
        <option value="workshop">Workshop</option>
        <option value="portal">Portal</option>
      </select>
      <!-- ADDED: Reset button (needed by JS binding) -->
      <button class="btn ghost" id="resetBtn" title="Reset progress" aria-label="Reset progress">↺ Reset</button>
    </div>
  </header>
  <div class="app">
    <aside class="side" role="navigation" aria-label="Quest Map">
      <div class="sectionTitle">Quest Map</div>
      <button class="navBtn active" data-mode="pemdas">Q1) Temple of PEMDAS <span class="pill mono"
          id="p_pemdas">0/10</span></button>
      <button class="navBtn" data-mode="integers">Q2) Integer Ice Caves <span class="pill mono"
          id="p_integers">0/10</span></button>
      <button class="navBtn" data-mode="coords">Q3) Quadrant Frontier <span class="pill mono"
          id="p_coords">0/10</span></button>
      <button class="navBtn" data-mode="words">Q4) Wordsmith Workshop <span class="pill mono"
          id="p_words">0/10</span></button>
      <button class="navBtn" data-mode="puzzles">Q5) Puzzle Portal <span class="pill mono"
          id="p_puzzles">0/10</span></button>
      <!-- NEW -->
      <button class="navBtn" data-mode="logic">Q6) Circuit of Logic <span class="pill mono"
          id="p_logic">0/10</span></button>
      <button class="navBtn" data-mode="mod">Q7) Modulus Monastery <span class="pill mono"
          id="p_mod">0/10</span></button>
      <!-- ADD: Mixed quest -->
      <button class="navBtn" data-mode="mix">Q8) Mixed Gauntlet <span class="pill mono" id="p_mix">0/10</span></button>
      <div class="sectionTitle">Progress</div>
      <div class="tiny" title="Mastery is checked on a rolling window of your last 20 attempts in each strand.">
        Mastery = 90%+ over last 20, 25+ attempts total, ≤10% hints, median ≤25s, across ≥2 days.
      </div>
      <div class="progress" style="margin:8px 0 6px"><span id="overallBar"></span></div>
      <div class="tiny" id="overallPct">0% complete</div>
      <div class="sectionTitle">Badges</div>
      <div id="badges"></div>
    </aside>

    <main id="main" role="main">
      <div class="grid">
        <section class="card">
          <h2 id="modeTitle">Q1: Temple of PEMDAS</h2>
          <div class="tiny">Tip: Use parentheses like you would in code to control precedence.</div>
          <div id="qWrap" style="margin-top:10px">
            <div class="question mono" id="question">Loading…</div>
            <div class="flex" style="margin-top:12px">
              <input id="answer" type="text" inputmode="text" placeholder="Enter your answer"
                aria-label="Your answer" />
              <button class="btn" id="submit">Submit</button>
              <button class="btn ghost" id="newQ">New</button>
              <button class="btn ghost" id="hintBtn" title="Costs 5 XP">💡 Hint</button>
              <span class="right pill" id="strandLabel">PEMDAS</span>
            </div>
            <!-- NEW: On-screen keypad -->
            <div id="keypad" class="flex tiny" style="gap:6px; margin-top:8px">
              <button type="button" class="btn ghost kp" data-insert="*">×</button>
              <button type="button" class="btn ghost kp" data-insert="/">÷</button>
              <button type="button" class="btn ghost kp" data-insert="-">−</button>
              <button type="button" class="btn ghost kp" data-insert="^">^</button>
              <button type="button" class="btn ghost kp" data-insert="T">T</button>
              <button type="button" class="btn ghost kp" data-insert="F">F</button>
              <button type="button" class="btn ghost kp-clear" title="Clear input">Clear</button>
            </div>
            <div class="feedback" id="feedback" role="status" aria-live="polite"></div>
            <div class="hint" id="hint" style="display:none"></div>
          </div>
          <div class="footer">Keyboard: <span class="kbd">Enter</span> to submit, <span class="kbd">N</span> new, <span
              class="kbd">H</span> hint.</div>
        </section>

        <section class="card">
          <h3>Strand Progress</h3>
          <div class="flex">
            <div class="pill">PEMDAS</div>
            <div class="progress" style="flex:1"><span id="bar_pemdas"></span></div>
          </div>
          <div class="flex">
            <div class="pill">Integers</div>
            <div class="progress" style="flex:1"><span id="bar_integers"></span></div>
          </div>
          <div class="flex">
            <div class="pill">Coordinates</div>
            <div class="progress" style="flex:1"><span id="bar_coords"></span></div>
          </div>
          <div class="flex">
            <div class="pill">Word</div>
            <div class="progress" style="flex:1"><span id="bar_words"></span></div>
          </div>
          <div class="flex">
            <div class="pill">Puzzles</div>
            <div class="progress" style="flex:1"><span id="bar_puzzles"></span></div>
          </div>
          <!-- NEW -->
          <div class="flex">
            <div class="pill">Logic</div>
            <div class="progress" style="flex:1"><span id="bar_logic"></span></div>
          </div>
          <div class="flex">
            <div class="pill">Modulus</div>
            <div class="progress" style="flex:1"><span id="bar_mod"></span></div>
          </div>
          <!-- ADD: Mixed progress row -->
          <div class="flex">
            <div class="pill">Mixed</div>
            <div class="progress" style="flex:1"><span id="bar_mix"></span></div>
          </div>
          <div style="margin-top:10px" class="tiny">
            When mastered, the strand pill shows “Mastered” and the bar fills. Correct = +10 XP (+2/step streak), Hint =
            −5 XP.
          </div>
        </section>

        <!-- NEW: Symbol Legend card -->
        <section class="card">
          <!-- Collapsible legend -->
          <details id="legend" open>
            <summary style="cursor:pointer; font-weight:600; list-style:none">
              <h3 style="display:inline; margin:0">Symbol Legend</h3>
            </summary>
            <div class="legend-grid" style="margin-top:8px">
              <!-- Arithmetic -->
              <div class="legend-item"><span class="legend-sym">×</span>
                <div>Multiply <span class="legend-note">(keyboard: <span class="kbd">*</span>)</span></div>
              </div>
              <div class="legend-item"><span class="legend-sym">÷</span>
                <div>Divide <span class="legend-note">(keyboard: <span class="kbd">/</span>)</span></div>
              </div>
              <div class="legend-item"><span class="legend-sym">−</span>
                <div>Subtract <span class="legend-note">(keyboard: <span class="kbd">-</span>)</span></div>
              </div>
              <div class="legend-item"><span class="legend-sym">^</span>
                <div>Exponent <span class="legend-note">(e.g., 2^3 = 8)</span></div>
              </div>
              <div class="legend-item"><span class="legend-sym">|x|</span>
                <div>Absolute value</div>
              </div>
              <div class="legend-item"><span class="legend-sym">T / F</span>
                <div>Truth values <span class="legend-note">(type T or F)</span></div>
              </div>
              <div class="legend-item"><span class="legend-sym">mod</span>
                <div>Remainder <span class="legend-note">(e.g., 17 mod 5 = 2)</span></div>
              </div>
            </div>
            <div class="tiny" style="margin-top:8px;">
              Tip: Answers can be numbers, T/F, or simplified fractions (a/b). Use <span class="kbd">*</span>, <span
                class="kbd">/</span>, <span class="kbd">-</span>, and <span class="kbd">^</span>.
            </div>
          </details>
        </section>

        <!-- NEW: Daily Goal -->
        <section class="card">
          <h3>Today's CS Goal</h3>
          <div class="tiny">Solve enough with good accuracy and low hint use.</div>
          <!-- NEW: day-specific label -->
          <div class="tiny" id="dailyGoalLabel" style="margin-top:4px;"></div>
          <div class="flex" style="margin-top:8px">
            <div class="pill">Today</div>
            <div class="right tiny">Completed: <b id="dailyCount">0/10</b></div>
          </div>
          <div class="meter" style="margin-top:8px"><span id="dailyBar"></span></div>
          <!-- NEW: criteria checklist -->
          <div id="dailyChecklist" class="tiny" style="display:grid; gap:6px; margin-top:8px"></div>
          <div class="tiny" id="dailyHint" style="margin-top:6px; opacity:.9"></div>
        </section>

        <!-- NEW: Daily Challenges -->
        <section class="card">
          <h3>Daily Challenges</h3>
          <div class="tiny">Complete mini‑goals for extra XP and fun.</div>
          <div id="challenges" style="display:grid; gap:8px; margin-top:8px"></div>
        </section>

        <!-- NEW: Strand Stats -->
        <section class="card">
          <div class="flex" style="justify-content: space-between; align-items: center;">
            <h3 style="margin:0">Strand Stats</h3>
            <button class="btn ghost tiny" id="resetStatsBtn"
              title="Clear stats shown below (does not change XP or progress)">Reset Stats</button>
          </div>
          <div id="statsBox" class="tiny"></div>
        </section>
      </div>
    </main>
  </div>

  <script>
    (function () {
      // Focus feature removed: global no‑op stubs (prevent legacy call errors)
      window.ensureFocus = window.ensureFocus || function () { };
      window.currentFocusPlan = window.currentFocusPlan || function () { return { accept: () => false }; };
      window.updateFocusUI = window.updateFocusUI || function () { };
      // If badges painter is not present, keep as no-op to avoid crashes on reset
      window.paintBadges = window.paintBadges || function () { };

      // Utility to safely call optional functions if they exist
      function callIf(fn, ...args) { if (typeof fn === 'function') return fn(...args); }

      // --- FX: starfield + confetti (single instance) ---
      const fx = document.getElementById('fx');
      const ctx = fx.getContext('2d');
      let W = 0, H = 0, stars = [], confetti = [];
      function resizeFX() { W = fx.width = window.innerWidth; H = fx.height = window.innerHeight; }
      window.addEventListener('resize', resizeFX); resizeFX();
      function initStars(n = 120) {
        stars = Array.from({ length: n }, () => ({
          x: Math.random() * W, y: Math.random() * H, r: Math.random() * 1.2 + 0.3,
          a: Math.random() * Math.PI * 2, s: 0.2 + Math.random() * 0.6
        }));
      }
      initStars();
      // ADD: shooting stars state + spawner (used in fxLoop)
      let shooting = [];
      function spawnShootingStar() {
        const y = Math.random() * H * 0.5 + 10;
        shooting.push({
          x: Math.random() * W * 0.6 + W * 0.2,
          y,
          vx: -6 - Math.random() * 3,
          vy: 1.5 + Math.random(),
          life: 24 + (Math.random() * 16),
          alpha: .9
        });
      }
      // FIX: define prefersReducedMotion before first use
      const prefersReducedMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Patch fxLoop to draw shooting stars (keeps existing stars + confetti)
      const _fxLoop = fxLoop;
      function fxLoop() {
        // occasional spawn
        if (!prefersReducedMotion && Math.random() < 0.02 && shooting.length < 3) spawnShootingStar();

        ctx.clearRect(0, 0, W, H);

        // stars
        ctx.save();
        for (const st of stars) {
          st.a += 0.02; const tw = (Math.sin(st.a) + 1) * 0.5;
          ctx.globalAlpha = 0.3 + tw * 0.7; ctx.fillStyle = '#9fb0d7';
          ctx.beginPath(); ctx.arc(st.x, st.y, st.r, 0, Math.PI * 2); ctx.fill();
          st.y += st.s * 0.15; if (st.y > H + 2) { st.y = -2; st.x = Math.random() * W; }
        }
        ctx.restore();

        // shooting stars
        if (!prefersReducedMotion && shooting.length) {
          ctx.save();
          for (let i = shooting.length - 1; i >= 0; i--) {
            const s = shooting[i];
            ctx.globalAlpha = Math.max(0, s.alpha);
            ctx.strokeStyle = '#cde3ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(s.x, s.y);
            ctx.lineTo(s.x + 16, s.y - 6);
            ctx.stroke();
            s.x += s.vx; s.y += s.vy; s.life -= 1; s.alpha -= 0.04;
            if (s.life <= 0 || s.x < -20 || s.y > H + 20) shooting.splice(i, 1);
          }
          ctx.restore();
        }

        // confetti (unchanged)
        ctx.save();
        for (let i = confetti.length - 1; i >= 0; i--) {
          const p = confetti[i];
          p.vy += p.g; p.x += p.vx; p.y += p.vy; p.rot += p.vr; p.life -= 1;
          p.alpha = Math.max(0, p.life / 100);
          ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color;
          ctx.translate(p.x, p.y); ctx.rotate(p.rot);
          ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h); ctx.setTransform(1, 0, 0, 1, 0, 0);
          if (p.life <= 0 || p.y > H + 20) confetti.splice(i, 1);
        }
        ctx.restore();

        requestAnimationFrame(fxLoop);
      }
      // replace loop with patched one
      if (!prefersReducedMotion) requestAnimationFrame(fxLoop);

      function celebrate(kind = 'correct') {
        if (prefersReducedMotion) return;
        const anchor = document.getElementById('qWrap');
        const rect = anchor ? anchor.getBoundingClientRect() : { left: W / 2, top: H / 3, right: W / 2, height: 0 };
        const cx = (rect.left + (rect.right ?? rect.left)) / 2; const cy = rect.top + 10;
        if (kind === 'mastery') addConfetti({ x: cx, y: cy, count: 160, spread: 1.4, colors: ['#ffd76a', '#ffcf67', '#fff2b0', '#9f6cff'] });
        else addConfetti({ x: cx, y: cy, count: 80, spread: 1.0 });
      }

      // --- Nav: single init with guard ---
      function setActiveNav(btn) {
        const btns = [...document.querySelectorAll('.navBtn')];
        btns.forEach(b => { b.classList.remove('active'); b.removeAttribute('aria-current'); });
        btn.classList.add('active'); btn.setAttribute('aria-current', 'page');
      }
      function initNav() {
        if (initNav._done) return;
        const btns = [...document.querySelectorAll('.navBtn')];
        btns.forEach(btn => {
          if (btn.dataset.bound) return;
          btn.addEventListener('click', () => {
            setActiveNav(btn);
            data.mode = btn.dataset.mode;
            renderMode();
            // FIX: Call nextQuestion directly (it's in scope)
            nextQuestion();
            if (data.themePref === 'auto') applyTheme('auto');
            save();
          });
          btn.dataset.bound = '1';
        });
        const initActive = document.querySelector('.navBtn.active');
        if (initActive) initActive.setAttribute('aria-current', 'page');
        initNav._done = true;
      }

      // --- Core state (single) ---
      const STRANDS = ['pemdas', 'integers', 'coords', 'words', 'puzzles', 'logic', 'mod', 'mix']; // + mix
      const state = JSON.parse(localStorage.getItem('csMathQuest') || '{}');
      const data = Object.assign({
        xp: 0, streak: 0, rank: 'Novice', mode: 'pemdas',
        correct: { pemdas: 0, integers: 0, coords: 0, words: 0, puzzles: 0, logic: 0, mod: 0, mix: 0 },
        hist: { pemdas: [], integers: [], coords: [], words: [], puzzles: [], logic: [], mod: [], mix: [] },
        mastered: { pemdas: false, integers: false, coords: false, words: false, puzzles: false, logic: false, mod: false, mix: false },
        daily: { date: '', solved: 0, goal: 20, completed: false, rules: { minSolved: 10, minAcc: 0.80, maxHintRate: 0.10 } },
        challenges: [],
        badges: {},
        boss: { done: false },
        themePref: 'auto',
        statsWin: { pemdas: [], integers: [], coords: [], words: [], puzzles: [], logic: [], mod: [], mix: [] },
        statsMode: 'hist'
      }, state);
      function ensureDataShape() {
        for (const k of STRANDS) {
          if (!data.correct || typeof data.correct[k] !== 'number') { if (!data.correct) data.correct = {}; if (!Number.isFinite(data.correct[k])) data.correct[k] = 0; }
          if (!data.hist || !Array.isArray(data.hist[k])) { if (!data.hist) data.hist = {}; if (!Array.isArray(data.hist[k])) data.hist[k] = []; }
          if (!data.mastered || typeof data.mastered[k] !== 'boolean') { if (!data.mastered) data.mastered = {}; if (typeof data.mastered[k] !== 'boolean') data.mastered[k] = false; }
          if (!data.statsWin || !Array.isArray(data.statsWin[k])) { if (!data.statsWin) data.statsWin = {}; if (!Array.isArray(data.statsWin[k])) data.statsWin[k] = []; }
        }
      }
      ensureDataShape();

      // --- Helpers (single) ---
      function $(sel) { return document.querySelector(sel); }
      function setText(sel, val) { const el = document.querySelector(sel); if (el) el.textContent = val; }
      function fmtPct(n) { return Math.round(Math.max(0, Math.min(1, n)) * 100) + '%'; }
      function save() { try { localStorage.setItem('csMathQuest', JSON.stringify(data)); } catch (_) { } }
      function toast(msg) {
        const el = document.createElement('div'); el.textContent = msg;
        Object.assign(el.style, { position: 'fixed', top: '12px', right: '12px', zIndex: 9999, background: '#151e44', color: '#fff', border: '1px solid #2a3672', padding: '8px 10px', borderRadius: '10px', boxShadow: '0 6px 20px #0008', opacity: '0', transform: 'translateY(-6px)', transition: 'opacity .2s, transform .2s' });
        document.body.appendChild(el);
        requestAnimationFrame(() => { el.style.opacity = '1'; el.style.transform = 'translateY(0)'; });
        setTimeout(() => { el.style.opacity = '0'; el.style.transform = 'translateY(-6px)'; setTimeout(() => el.remove(), 250); }, 2000);
      }
      // ADD: HUD updater (fixes ReferenceError) - move this before initialStart
      function updateHUD() {
        setText('#xp', String(data.xp || 0));
        setText('#streak', String(data.streak || 0));
        setText('#rank', data.rank || 'Novice');
        if (typeof updateHintButton === 'function') updateHintButton();
      }

      // --- Generators + answer checking + challenges (required by nextQuestion/checkAnswer) ---
      const rnd = (a, b) => (Math.random() * (b - a + 1) + a) | 0;
      const choice = a => a[(Math.random() * a.length) | 0];
      function reduceFrac(n, d) {
        const g = (x, y) => y ? g(y, x % y) : Math.abs(x);
        const gg = g(n, d) || 1;
        const s = Math.sign(n) * Math.sign(d) || 1;
        n = Math.abs(n) / gg; d = Math.abs(d) / gg;
        return { n: s < 0 ? -n : n, d };
      }
      const gens = {
        pemdas() {
          const a = rnd(2, 12), b = rnd(2, 9), c = rnd(1, 8), d = rnd(1, 6);
          const pm = choice([['+', (x, y) => x + y], ['-', (x, y) => x - y]]);
          const pat = choice([1, 2, 3, 4]);
          if (pat === 1) {
            const expr = `${a} + ${b} * (${c} ${pm[0]} ${d})`;
            return { q: `Evaluate: ${expr}`, ans: a + b * pm[1](c, d), hint: 'Parentheses → multiply → add/subtract.' };
          } else if (pat === 2) {
            const expr = `(${a} ${pm[0]} ${b}) * ${c} - ${d}`;
            return { q: `Evaluate: ${expr}`, ans: (pm[1](a, b)) * c - d, hint: 'Work left parentheses first, then mul, then sub.' };
          } else if (pat === 3) {
            const e = rnd(2, 5);
            const expr = `${c}^${e} ${pm[0]} ${b} * ${d}`;
            return { q: `Evaluate: ${expr}`, ans: (c ** e) + (pm[0] === '+' ? 1 : -1) * b * d, hint: 'Exponents before multiply; then add/subtract.' };
          } else {
            const expr = `${a} - (${b} ${pm[0]} ${c}) * ${d}`;
            return { q: `Evaluate: ${expr}`, ans: a - pm[1](b, c) * d, hint: 'Do parentheses, multiply, then subtract.' };
          }
        },
        integers() {
          const a = rnd(-20, 20), b = rnd(-20, 20), op = choice(['+', '-', '*']);
          const ans = op === '+' ? a + b : op === '-' ? a - b : a * b;
          return { q: `Compute: ${a} ${op} ${b}`, ans, hint: 'Negative × negative = positive.' };
        },
        coords() {
          const x = rnd(-9, 9), y = rnd(-9, 9);
          return { q: `Point P(${x}, ${y}). What is x + y?`, ans: x + y, hint: 'Add the x and y coordinates.' };
        },
        words() {
          const a = rnd(3, 12), b = rnd(2, 9);
          return { q: `Translate and compute: "the product of ${a} and ${b}, then add ${a}"`, ans: a * b + a, hint: 'Product means multiply, then add.' };
        },
        puzzles() {
          const a = rnd(2, 6), d = rnd(2, 7), n = rnd(5, 8);
          const seq = Array.from({ length: n - 1 }, (_, i) => a + i * d).join(', ');
          return { q: `Sequence: ${seq}, … What is the ${n}th term?`, ans: a + (n - 1) * d, hint: 'aₙ = a₁ + (n−1)d.' };
        },
        logic() {
          const A = Math.random() < 0.5, B = Math.random() < 0.5;
          const op = choice(['∧', '∨', '→']);
          let ans; if (op === '∧') ans = A && B; else if (op === '∨') ans = A || B; else ans = (!A) || B;
          return { q: `Let A=${A ? 'T' : 'F'}, B=${B ? 'T' : 'F'}. Evaluate: A ${op} B`, ans: ans ? 'T' : 'F', hint: 'A→B is false only when A=T, B=F.' };
        },
        mod() {
          const n = rnd(10, 99), m = choice([3, 4, 5, 6, 7, 8, 9]);
          return { q: `Compute: ${n} Mod ${m}`, ans: n % m, hint: 'Remainder after dividing n by m.' };
        },
        mix() {
          const base = ['pemdas', 'integers', 'coords', 'words', 'puzzles', 'logic', 'mod'];
          const pick = base[(Math.random() * base.length) | 0];
          const g = this[pick]();
          return {
            q: `[${pick.toUpperCASE()}] ${g.q}`,
            ans: g.ans,
            hint: g.hint || 'Use the right tool for the strand shown.',
            exp: g.exp || ''
          };
        }
      };
      window.gens = gens;

      function norm(input) {
        if (typeof input === 'number') return { kind: 'num', v: input };
        const s = String(input).trim();
        if (/^[tTfF]$/.test(s)) return { kind: 'bool', v: s.toUpperCase() };
        if (/^-?\d+\/-?\d+$/.test(s)) {
          const [a, b] = s.split('/').map(Number); if (b === 0) return { kind: 'str', v: s };
          const { n, d } = reduceFrac(a, b); return { kind: 'frac', v: `${n}/${d}` };
        }
        if (/^-?\d+(\.\d+)?$/.test(s)) return { kind: 'num', v: Number(s) };
        return { kind: 'str', v: s.toLowerCase() };
      }
      function eqAns(user, correct) {
        const u = norm(user), c = norm(correct);
        if (u.kind === 'bool' || c.kind === 'bool') return u.v === (typeof c.v === 'string' ? c.v.toUpperCase() : c.v);
        if (u.kind === 'frac' || c.kind === 'frac') return u.v === (c.kind === 'frac' ? c.v : String(c.v));
        if (u.kind === 'num' && c.kind === 'num') return Math.abs(u.v - c.v) < 1e-9;
        return String(user).trim().toLowerCase() === String(correct).trim().toLowerCase();
      }

      // Daily challenge progress
      function applyChallengeProgress({ correct, noHint, strand, ms = 0, streak = 0 }) {
        if (!Array.isArray(data.challenges) || !data.challenges.length) return;
        let changed = false;
        for (const ch of data.challenges) {
          if (ch.done) continue;
          switch (ch.type) {
            case 'strand':
              if (correct && strand === ch.strand) { ch.progress++; changed = true; }
              break;
            case 'streak': {
              const prog = Math.min(streak, ch.target);
              if (prog > (ch.progress || 0)) { ch.progress = prog; changed = true; }
              break;
            }
            case 'nohint':
              if (correct && noHint) { ch.progress++; changed = true; }
              break;
            case 'speed': {
              const thrMs = Math.max(1000, (ch.threshold || 15) * 1000);
              if (correct && ms > 0 && ms <= thrMs) { ch.progress++; changed = true; }
              break;
            }
          }
          if (!ch.done && ch.progress >= ch.target) {
            ch.done = true;
            const reward = ch.reward || 20;
            data.xp += reward; data.rank = computeRank(data.xp);
            toast(`🎯 Challenge complete! (+${reward} XP)`);
            changed = true;
          }
        }
        if (changed) { updateHUD(); save(); updateChallengesUI(); }  // FIX: call renamed function
      }

      // --- Current question + flow ---
      let current = null;
      function nextQuestion() {
        const strand = data.mode;
        const gen = gens[strand] || gens.pemdas;
        const g = gen.call(gens);
        current = { strand, q: g.q, ans: g.ans, hinted: false, t0: performance.now(), hintText: g.hint || 'Try breaking it into smaller steps.', explain: g.exp || '' };
        const qEl = document.getElementById('question');
        const aEl = document.getElementById('answer');
        const fb = document.getElementById('feedback');
        const hint = document.getElementById('hint');
        if (qEl) qEl.textContent = g.q;
        if (aEl) { aEl.value = ''; aEl.focus(); aEl.select(); }
        if (fb) { fb.textContent = ''; fb.className = 'feedback'; }
        if (hint) { hint.textContent = ''; hint.style.display = 'none'; }
      }
      function showHint() {
        console.log('Hint button clicked');  // Remove after testing
        if (!current) { console.log('No current question'); return; }
        const hint = document.getElementById('hint');
        if (!hint) { console.log('Hint element not found'); return; }
        if (!current.hinted) {
          current.hinted = true;
          data.xp = Math.max(0, (data.xp || 0) - 5);
          data.rank = computeRank(data.xp);
          fxXP(-5);
          updateHUD();  // This calls updateHintButton()
          save();
        }
        hint.textContent = current.hintText;
        hint.style.display = '';
        console.log('Hint shown:', current.hintText);  // Remove after testing
      }
      function checkAnswer() {
        const aEl = document.getElementById('answer');
        const fb = document.getElementById('feedback');
        if (!current || !aEl || !fb) return;
        const user = aEl.value;
        const elapsed = performance.now() - current.t0;

        const prevStreak = data.streak || 0;

        const correct = eqAns(user, current.ans);
        if (correct) {
          data.xp += 10;
          data.streak = (data.streak || 0) + 1;
          data.rank = computeRank(data.xp);
          data.correct[current.strand] = (data.correct[current.strand] || 0) + 1;
          data.daily.solved = (data.daily.solved || 0) + 1;
          fb.textContent = 'Correct! ' + (current.hinted ? '(with hint)' : '');
          fb.className = 'feedback good';
          celebrate('correct');

          if (data.streak === 3) toast('🔥 Streak x3! Nice flow.');
          if (data.streak === 5) { toast('⚡ Streak x5! Keep it going.'); celebrate('mastery'); }
          if (data.streak === 10) { toast('🏆 Streak x10! You’re on fire!'); celebrate('mastery'); }

          applyChallengeProgress({ correct: true, noHint: !current.hinted, strand: current.strand, ms: elapsed, streak: data.streak });
        } else {
          data.streak = 0;
          fb.textContent = `Not quite. Correct answer was: ${typeof current.ans === 'number' ? current.ans : String(current.ans)}`;
          fb.className = 'feedback bad';
          const hint = document.getElementById('hint');
          if (hint) {
            hint.textContent = current.explain ? `Explanation: ${current.explain}` : 'Review the hint and try a similar one.';
            hint.style.display = '';
          }
          if (prevStreak >= 3) toast(`Streak of ${prevStreak} ended. You’ve got this!`);
        }
        (data.hist[current.strand] = data.hist[current.strand] || []).push({
          t: Date.now(), correct, hint: current.hinted, ms: Math.round(elapsed)
        });
        if (data.hist[current.strand].length > 400) data.hist[current.strand] = data.hist[current.strand].slice(-300);

        (data.statsWin[current.strand] = data.statsWin[current.strand] || []).push({
          t: Date.now(), correct, hint: current.hinted, ms: Math.round(elapsed)
        });
        if (data.statsWin[current.strand].length > 120) {
          data.statsWin[current.strand] = data.statsWin[current.strand].slice(-100);
        }
        // FIX: Force stats UI update for the current strand
        updateStatsUI();

        updateHUD();
        updateProgress();
        updateEngagementUI();  // FIX: this was calling the overwritten function; now calls daily UI
        checkDailyCompletion();
        save();
      }

      // --- Theme ---
      function themeForMode(mode) {
        switch (mode) {
          case 'pemdas': return 'dungeon';
          case 'integers': return 'ice';
          case 'coords': return 'space';
          case 'words': return 'workshop';
          case 'puzzles': return 'portal';
          case 'logic': return 'workshop';
          case 'mod': return 'dungeon';
          case 'mix': return 'portal';
          default: return 'space';
        }
      }
      function applyTheme(theme) {
        const pref = theme || data.themePref || 'auto';
        const resolved = pref === 'auto' ? themeForMode(data.mode) : pref;
        // FIX: Ensure DOM update and log for debugging
        document.documentElement.setAttribute('data-theme', resolved);
        console.log('Applied theme:', resolved);  // Remove after testing
        data.themePref = pref;
        const sel = document.getElementById('themeSelect');
        if (sel && sel.value !== pref) sel.value = pref;
        save();
      }
      function initThemeSelect() {
        const sel = document.getElementById('themeSelect');
        if (!sel) return;
        sel.value = data.themePref || 'auto';
        if (!sel.dataset.bound) {
          sel.addEventListener('change', () => {
            applyTheme(sel.value || 'auto');
          });
          sel.dataset.bound = '1';
        }
      }

      function renderMode() {
        const titles = {
          pemdas: 'Q1: Temple of PEMDAS', integers: 'Q2: Integer Ice Caves', coords: 'Q3: Quadrant Frontier',
          words: 'Q4: Wordsmith Workshop', puzzles: 'Q5: Puzzle Portal', logic: 'Q6: Circuit of Logic',
          mod: 'Q7: Modulus Monastery', mix: 'Q8: Mixed Gauntlet', boss: 'Boss Battle: Final Gauntlet'
        };
        const ICON = { pemdas: '🧮', integers: '➕', coords: '📍', words: '📝', puzzles: '🧩', logic: '🔌', mod: '🧪', mix: '🎯' };
        setText('#modeTitle', titles[data.mode] || 'Quest');
        const lbl = document.getElementById('strandLabel');
        if (lbl) lbl.textContent = `${ICON[data.mode] || ''} ${(data.mode || '').toUpperCase()}`;
      }

      // --- Rank ---
      function computeRank(xp) {
        if (xp >= 10000) return 'Grandmaster';
        if (xp >= 5000) return 'Master';
        if (xp >= 2000) return 'Expert';
        if (xp >= 1000) return 'Advanced';
        if (xp >= 500) return 'Intermediate';
        if (xp >= 200) return 'Apprentice';
        return 'Novice';
      }

      // --- Mastery ---
      function computeMasteryFor(strand) {
        const arr = (data.hist[strand] || []).slice(-20);
        if (arr.length < 25) return false;
        const acc = arr.reduce((s, a) => s + (a.correct ? 1 : 0), 0) / arr.length;
        const hintRate = arr.reduce((s, a) => s + (a.hint ? 1 : 0), 0) / arr.length;
        const medMs = arr.map(a => a.ms || 0).filter(x => Number.isFinite(x) && x > 0).sort((a, b) => a - b);
        const med = medMs.length ? (medMs.length % 2 ? medMs[(medMs.length - 1) / 2] : (medMs[medMs.length / 2 - 1] + medMs[medMs.length / 2]) / 2) : 0;
        const days = new Set(arr.map(a => new Date(a.t).toDateString())).size;
        return acc >= 0.9 && hintRate <= 0.1 && med <= 25000 && days >= 2;
      }
      function recomputeMastery() { STRANDS.forEach(k => { data.mastered[k] = computeMasteryFor(k); }); }
      const _prevBarPct = {};
      function updateProgress() {
        recomputeMastery();
        STRANDS.forEach(k => {
          const pill = document.getElementById('p_' + k);
          const bar = document.getElementById('bar_' + k);
          if (data.mastered[k]) {
            if (pill) { pill.textContent = 'Mastered'; pill.classList.add('mastered'); }
            if (bar) bar.style.width = '100%';
          } else {
            if (pill) { pill.textContent = `${data.correct[k]}/10`; pill.classList.remove('mastered'); }
            const pctNum = Math.min(100, (data.correct[k] || 0) * 10);
            if (bar) {
              const prev = _prevBarPct[k] || 0;
              bar.style.width = pctNum + '%';
              if (pctNum > prev) { bar.classList.add('bump'); setTimeout(() => bar.classList.remove('bump'), 650); }
              _prevBarPct[k] = pctNum;
            }
          }
        });
      }

      // --- Daily ---
      function ensureDaily() {
        const today = new Date().toDateString();
        if (!data.daily || data.daily.date !== today) {
          data.daily = { date: today, solved: 0, goal: 20, completed: false, rules: { minSolved: 10, minAcc: 0.80, maxHintRate: 0.10 } };
          data.challenges = [
            { type: 'strand', strand: 'pemdas', target: 5, progress: 0, reward: 20, done: false },
            { type: 'streak', target: 5, progress: 0, reward: 15, done: false },
            { type: 'nohint', target: 3, progress: 0, reward: 10, done: false },
            { type: 'speed', threshold: 10, target: 2, progress: 0, reward: 25, done: false }
          ];
        }
      }
      function checkDailyCompletion() {
        if (data.daily.completed) return;
        const arr = Object.values(data.hist).flat().filter(a => new Date(a.t).toDateString() === data.daily.date);
        const solved = arr.length;
        const correct = arr.reduce((s, a) => s + (a.correct ? 1 : 0), 0);
        const hints = arr.reduce((s, a) => s + (a.hint ? 1 : 0), 0);
        const acc = solved ? correct / solved : 0;
        const hintRate = solved ? hints / solved : 0;
        const minSolved = data.daily.rules.minSolved || 10;
        const minAcc = data.daily.rules.minAcc || 0.80;
        const maxHintRate = data.daily.rules.maxHintRate || 0.10;
        if (solved >= minSolved && acc >= minAcc && hintRate <= maxHintRate) {
          data.daily.completed = true;
          data.xp += 50;
          data.rank = computeRank(data.xp);
          toast('🎉 Daily goal complete! (+50 XP)');
          updateHUD(); save();
        }
      }
      function updateEngagementUI() {
        const arr = Object.values(data.hist).flat().filter(a => new Date(a.t).toDateString() === data.daily.date);
        const solved = arr.length;
        const correct = arr.reduce((s, a) => s + (a.correct ? 1 : 0), 0);
        const acc = solved ? correct / solved : 0;
        const hints = arr.reduce((s, a) => s + (a.hint ? 1 : 0), 0);
        const hintRate = solved ? hints / solved : 0;
        const minSolved = data.daily.rules.minSolved || 10;
        const minAcc = data.daily.rules.minAcc || 0.80;
        const maxHintRate = data.daily.rules.maxHintRate || 0.10;
        const pct = Math.min(100, (solved / data.daily.goal) * 100);
        setText('#dailyCount', `${solved}/${data.daily.goal}`);
        const bar = document.getElementById('dailyBar');
        if (bar) bar.style.width = pct + '%';
        const checklist = document.getElementById('dailyChecklist');
        if (checklist) {
          checklist.innerHTML = `
            <div>Solve ${minSolved}+ problems: ${solved >= minSolved ? '✅' : '❌'}</div>
            <div>Accuracy ≥${Math.round(minAcc * 100)}%: ${acc >= minAcc ? '✅' : '❌'}</div>
            <div>Hints ≤${Math.round(maxHintRate * 100)}%: ${hintRate <= maxHintRate ? '✅' : '❌'}</div>
          `;
        }
        const hintEl = document.getElementById('dailyHint');
        if (hintEl) {
          hintEl.textContent = data.daily.completed ? 'Goal achieved! 🎉' : `Need ${minSolved - solved} more solves, ${Math.round((minAcc - acc) * 100)}% better accuracy, or ${(hintRate - maxHintRate) * 100}% fewer hints.`;
        }
        const label = document.getElementById('dailyGoalLabel');
        if (label) label.textContent = `Goal: ${data.daily.goal} solves with ≥${Math.round(minAcc * 100)}% accuracy and ≤${Math.round(maxHintRate * 100)}% hints.`;
      }

      // --- Challenges ---
      // RENAME: to avoid overwrite, call this updateChallengesUI
      function updateChallengesUI() {
        const challengesEl = document.getElementById('challenges');
        if (!challengesEl) return;
        challengesEl.innerHTML = data.challenges.map(ch => {
          const pct = Math.min(100, (ch.progress / ch.target) * 100);
          const done = ch.done;
          const icon = done ? '✅' : '⏳';
          const desc = ch.type === 'strand' ? `Solve ${ch.target} ${ch.strand} problems` :
            ch.type === 'streak' ? `Reach a streak of ${ch.target}` :
              ch.type === 'nohint' ? `Solve ${ch.target} without hints` :
                `Solve ${ch.target} in under ${ch.threshold}s`;
          return `<div class="challenge ${done ? 'done' : ''}">
            <div>${icon} ${desc}</div>
            <div class="prog">${ch.progress}/${ch.target}</div>
          </div>`;
        }).join('');
      }

      // --- Stats ---
      function calcStats(strand) {
        const src = (data.statsWin && Array.isArray(data.statsWin[strand])) ? data.statsWin[strand] : [];
        const arr = src.slice(-20);
        const n = arr.length;
        const acc = n ? arr.reduce((s, a) => s + (a.correct ? 1 : 0), 0) / n : 0;
        const times = arr.map(a => a.ms || 0).filter(x => Number.isFinite(x) && x > 0).sort((a, b) => a - b);
        const med = times.length ? (times.length % 2 ? times[(times.length - 1) / 2] : (times[times.length / 2 - 1] + times[times.length / 2]) / 2) : 0;
        const hint = n ? arr.reduce((s, a) => s + (a.hint ? 1 : 0), 0) / n : 0;
        return { n, acc, med, hint };
      }
      function updateStatsUI() {
        const box = document.getElementById('statsBox');
        if (!box) return;
        const strand = data.mode;
        const stats = calcStats(strand);
        const medSec = stats.med ? (stats.med / 1000).toFixed(1) : '—';
        const accPct = Math.round(stats.acc * 100);
        const hintPct = Math.round(stats.hint * 100);
        box.innerHTML = `
          <div class="stats-row">
            <div class="pill">Last ${stats.n} attempts</div>
            <div class="pill">${accPct}% accuracy</div>
            <div class="pill">${medSec}s median time</div>
            <div class="pill">${hintPct}% hints</div>
          </div>
        `;
      }

      // --- Badges ---
      function paintBadges() {
        const badgesEl = document.getElementById('badges');
        if (!badgesEl) return;
        const badges = [
          { id: 'first_solve', name: 'First Solve', desc: 'Solve your first problem', check: () => Object.values(data.correct).some(c => c > 0) },
          { id: 'streak_5', name: 'Hot Streak', desc: 'Reach a 5-problem streak', check: () => data.streak >= 5 },
          { id: 'master_pemdas', name: 'PEMDAS Master', desc: 'Master PEMDAS strand', check: () => data.mastered.pemdas },
          { id: 'daily_complete', name: 'Daily Champion', desc: 'Complete a daily goal', check: () => data.daily.completed },
          { id: 'xp_500', name: 'XP Hunter', desc: 'Earn 500 XP', check: () => data.xp >= 500 },
          { id: 'all_mastered', name: 'Grandmaster', desc: 'Master all strands', check: () => STRANDS.every(k => data.mastered[k]) }
        ];
        badgesEl.innerHTML = badges.filter(b => b.check()).map(b => `<div class="badge" title="${b.desc}">🏆 ${b.name}</div>`).join('');
      }

      // --- Hint button state ---
      function updateHintButton() {
        const btn = document.getElementById('hintBtn');
        if (!btn) return;
        const can = (data.xp || 0) >= 5;
        btn.disabled = !can;
        btn.title = can ? 'Costs 5 XP' : 'Need 5 XP for a hint';
        btn.style.opacity = can ? '1' : '0.7';
      }

      // ADD: XP floater helper (used by checkAnswer/showHint)
      function fxXP(delta = 0) {
        try {
          const stat = document.getElementById('xp');
          if (!stat) return;
          const r = stat.getBoundingClientRect();
          const el = document.createElement('div');
          el.className = 'xp-floater' + (delta < 0 ? ' neg' : '');
          el.textContent = (delta >= 0 ? `+${delta}` : `${delta}`) + ' XP';
          el.style.left = (r.left + r.width / 2) + 'px';
          el.style.top = (r.top - 2) + 'px';
          document.body.appendChild(el);
          setTimeout(() => el.remove(), 900);
        } catch (_) { /* no-op */ }
      }

      // ADD: full reset handler used by the header Reset button
      function resetAll() {
        if (!confirm('Reset XP, progress, history, mastery, daily, challenges, badges, and stats?')) return;

        // Core
        data.xp = 0;
        data.streak = 0;
        data.rank = 'Novice';

        // Per-strand
        STRANDS.forEach(k => {
          data.correct[k] = 0;
          data.hist[k] = [];
          data.mastered[k] = false;
          if (data.statsWin && Array.isArray(data.statsWin[k])) data.statsWin[k] = [];
        });
        // reset previous bar cache
        if (typeof _prevBarPct === 'object') STRANDS.forEach(k => _prevBarPct[k] = 0);

        // Meta
        data.badges = {};
        data.boss = { done: false };
        data.challenges = [];
        data.daily = null;
        ensureDaily();

        save();

        // UI refresh
        updateHUD();
        updateProgress();
        paintBadges && paintBadges();
        updateStatsUI();
        updateEngagementUI();

        // Re-apply theme preference
        applyTheme(data.themePref || 'auto');

        nextQuestion();
      }
      // Make available for bindings that call via window.*
      window.resetAll = resetAll;

      // Bind Reset Stats (reset current strand’s progress + stats only)
      (function bindResetStats() {
        const btn = document.getElementById('resetStatsBtn');
        if (btn && !btn.dataset.bound) {
          btn.addEventListener('click', () => {
            const strand = data.mode || 'pemdas';
            const label = strand.toUpperCase();
            if (!confirm(`Reset ${label} progress and stats? (does not change XP)`)) return;

            data.correct[strand] = 0;
            data.hist[strand] = [];
            data.mastered[strand] = false;
            if (data.statsWin && Array.isArray(data.statsWin[strand])) data.statsWin[strand] = [];
            if (typeof _prevBarPct === 'object') _prevBarPct[strand] = 0;

            save();
            updateProgress();
            updateStatsUI();
            toast(`${label} reset.`);
            nextQuestion();
          });
          btn.dataset.bound = '1';
        }
      })();

      // --- Controls ---
      function bindControls() {
        const submit = document.getElementById('submit');
        const newQ = document.getElementById('newQ');
        const hintBtn = document.getElementById('hintBtn');
        const ans = document.getElementById('answer');
        if (submit && !submit.dataset.bound) { submit.addEventListener('click', checkAnswer); submit.dataset.bound = '1'; }
        if (newQ && !newQ.dataset.bound) { newQ.addEventListener('click', nextQuestion); newQ.dataset.bound = '1'; }
        if (hintBtn && !hintBtn.dataset.bound) { hintBtn.addEventListener('click', showHint); hintBtn.dataset.bound = '1'; }
        if (ans && !ans.dataset.bound) {
          ans.addEventListener('keydown', e => { if (e.key === 'Enter') checkAnswer(); });
          ans.dataset.bound = '1';
        }
      }
      document.querySelectorAll('.kp, .kp-clear').forEach(btn => {
        if (btn.dataset.bound) return;
        btn.addEventListener('click', () => {
          const a = document.getElement('answer'); if (!a) return;
          if (btn.classList.contains('kp-clear')) { a.value = ''; a.focus(); return; }
          const ins = btn.dataset.insert || '';
          const start = a.selectionStart ?? a.value.length;
          const end = a.selectionEnd ?? a.value.length;
          a.value = a.value.slice(0, start) + ins + a.value.slice(end);
          const pos = start + ins.length;
          a.setSelectionRange(pos, pos);
          a.focus();
        });
        btn.dataset.bound = '1';
      });
      document.addEventListener('keydown', e => {
        if (e.key === 'n' || e.key === 'N') nextQuestion();
        else if (e.key === 'h' || e.key === 'H') showHint();
      });

      // Bind Reset (full app reset) – call via window to avoid ReferenceError during binding
      const resetEl = document.getElementById('resetBtn');
      if (resetEl && !resetEl.dataset.bound) {
        resetEl.addEventListener('click', () => window.resetAll && window.resetAll());
        resetEl.dataset.bound = '1';
      }

      // Make Strand Progress rows clickable to switch quests
      bindProgressNav();

      // Make Strand Progress rows clickable to switch quests
      function bindProgressNav() {
        try {
          STRANDS.forEach(k => {
            const bar = document.getElementById('bar_' + k);
            if (!bar) return;
            const row = bar.closest('.flex') || bar.parentElement;
            if (!row || row.dataset.modeBound) return;
            row.style.cursor = 'pointer';
            row.title = 'Go to ' + k.toUpperCase();
            row.addEventListener('click', () => {
              const btn = document.querySelector('.navBtn[data-mode="' + k + '"]');
              if (btn) btn.click();
            });
            row.dataset.modeBound = '1';
          });
        } catch (_) { /* no-op */ }
      }

      // --- Start ---
      function initialStart() {
        ensureDaily();
        initNav();
        initThemeSelect();
        applyTheme(data.themePref || 'auto');
        renderMode();
        updateHUD();
        updateProgress();
        paintBadges();
        updateStatsUI();
        updateEngagementUI();  // FIX: calls daily UI
        updateChallengesUI();  // FIX: add call to challenges UI
        bindControls();
        nextQuestion();
      }

      // Ensure nav click binding is active
      initNav();
      initialStart();
    })();
  </script>
</body>

</html>
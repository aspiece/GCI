<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>PEMDAS Playground — Order of Operations Adventure</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root {
            --bg: #f7fbff;
            --card: #ffffff;
            --accent: #0b63b3;
            --muted: #4b5563;
            --text: #0f1724;
            --button-text: #ffffff;
            --secondary-bg: #e6eef9;
            --secondary-color: var(--accent);
        }

        /* Dark and High Contrast themes are applied via body classes */
        body.theme-dark {
            --bg: #07112a;
            --card: #0b1624;
            --accent: #0b63b3;
            --muted: #9fb6d9;
            --text: #e6eef9;
            --button-text: #e6eef9;
            --secondary-bg: #112233;
            --secondary-color: var(--button-text);
        }

        body.theme-high-contrast {
            --bg: #000000;
            --card: #000000;
            --accent: #ffff00;
            --muted: #ffffff;
            --text: #ffffff;
            --button-text: #000000;
            --secondary-bg: transparent;
            --secondary-color: #ffff00;
        }

        body {
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;
            margin: 0;
            background: linear-gradient(180deg, #eaf4ff 0%, var(--bg) 60%);
            color: var(--text);
        }

        .wrap {
            max-width: 880px;
            margin: 36px auto;
            padding: 18px
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 18px
        }

        h1 {
            font-size: 20px;
            margin: 0
        }

        .card {
            background: var(--card);
            border-radius: 10px;
            box-shadow: 0 6px 18px rgba(10, 20, 40, 0.06);
            padding: 18px;
            margin-bottom: 12px
        }

        /* Badges shown next to problems to indicate features */
        .badges {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap
        }

        .badge {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 999px;
            background: var(--accent);
            color: var(--button-text);
            font-weight: 600;
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);
        }

        .badge.secondary {
            background: var(--secondary-bg);
            color: var(--text);
            border: 1px solid rgba(11, 99, 179, 0.08);
            font-weight: 500;
        }

        .controls {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--muted);
            font-size: 13px
        }

        /* Badge cabinet styles */
        .cabinet {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .badge.trophy {
            width: 44px;
            height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            font-size: 11px;
            padding: 6px;
            box-shadow: 0 4px 12px rgba(2, 6, 23, 0.12);
            cursor: default;
        }

        /* earned badges use CSS vars so we can tint per-level in JS */
        .badge.trophy.earned {
            background-image: linear-gradient(180deg, var(--badge-bg1, #ffde59), var(--badge-bg2, #f29f05));
            color: var(--badge-text, #111);
            font-weight: 700;
        }

        /* focus and icon styles for keyboard navigation */
        .badge.trophy:focus {
            outline: 3px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 6px 18px rgba(2, 6, 23, 0.18), 0 0 0 3px rgba(11, 99, 179, 0.18);
        }

        .badge.trophy .icon {
            width: 16px;
            height: 16px;
            display: inline-block;
            vertical-align: middle;
            margin-right: 6px;
        }

        /* small retro pixel colors for earned vs locked (defaults) */
        .badge.trophy.earned {
            background-image: linear-gradient(180deg, var(--badge-bg1, #ffde59), var(--badge-bg2, #f29f05));
            color: var(--badge-text, #111);
        }

        .badge.trophy.locked {
            background-image: linear-gradient(180deg, var(--badge-locked-1, #e6e6e6), var(--badge-locked-2, #cfcfcf));
            color: var(--badge-locked-text, #6b6b6b);
        }

        /* visually-hidden helper for ARIA live region */
        .sr-only {
            position: absolute !important;
            width: 1px !important;
            height: 1px !important;
            padding: 0 !important;
            margin: -1px !important;
            overflow: hidden !important;
            clip: rect(0, 0, 0, 0) !important;
            white-space: nowrap !important;
            border: 0 !important;
        }

        /* Toast stack */
        #toast-stack {
            position: fixed;
            right: 18px;
            bottom: 18px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 9999;
            align-items: flex-end;
        }

        .toast {
            background: var(--card);
            color: var(--text);
            padding: 10px 14px;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(2, 6, 23, 0.12);
            max-width: 320px;
            opacity: 1;
        }

        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(2, 6, 23, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
        }

        .modal {
            background: var(--card);
            color: var(--text);
            border-radius: 12px;
            padding: 18px;
            width: 92%;
            max-width: 520px;
            box-shadow: 0 12px 40px rgba(2, 6, 23, 0.2);
        }

        .modal h3 {
            margin: 0 0 8px 0
        }

        .modal .modal-row {
            display: flex;
            gap: 12px;
            align-items: center
        }

        .modal .pixel-art {
            width: 64px;
            height: 64px;
            flex: 0 0 64px
        }

        .modal .meta {
            color: var(--muted);
            font-size: 13px
        }

        .modal .close {
            margin-left: auto;
            background: transparent;
            border: 0;
            font-size: 16px;
            cursor: pointer
        }

        .badge.trophy.locked {
            background: rgba(0, 0, 0, 0.06);
            color: var(--muted);
            border: 1px dashed rgba(0, 0, 0, 0.06);
        }

        select,
        input[type=number] {
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid #d1d5db;
            background: #fff
        }

        button {
            background: var(--accent);
            color: var(--button-text);
            border: 0;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer
        }

        button.secondary {
            background: var(--secondary-bg);
            color: var(--secondary-color);
            border: 1px solid rgba(11, 99, 179, 0.12)
        }

        .problem {
            font-size: 28px;
            font-weight: 600;
            margin: 8px 0
        }

        .feedback {
            margin-top: 10px;
            font-weight: 600
        }

        .steps {
            background: var(--secondary-bg);
            color: var(--text);
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace
        }

        .meta {
            display: flex;
            gap: 12px;
            align-items: center;
            margin-top: 8px;
            color: var(--muted);
            font-size: 13px
        }

        .score {
            background: var(--secondary-bg);
            color: var(--text);
            padding: 8px;
            border-radius: 8px
        }

        footer {
            margin-top: 18px;
            color: var(--muted);
            font-size: 13px;
            text-align: center
        }

        @media (max-width:520px) {
            .controls {
                flex-direction: column;
                align-items: stretch
            }
        }

        /* Two-column layout: main + right sidebar for badges/legend */
        .cols {
            display: flex;
            gap: 18px;
            align-items: flex-start;
        }

        .main {
            flex: 1 1 auto;
            min-width: 0;
        }

        .sidebar {
            flex: 0 0 30%;
            max-width: 320px;
        }

        @media (max-width:800px) {
            .cols {
                flex-direction: column;
            }

            .sidebar {
                flex: none;
                max-width: none;
                width: auto
            }
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <h1>PEMDAS Playground — Order of Operations Adventure</h1>
            <div style="color:var(--muted);font-size:13px">Mnemonic: PEMDAS (Parentheses, Exponents, MD, AS)</div>
        </header>

        <div class="cols">
            <main class="main">
                <section class="card" aria-labelledby="options-heading">
                    <h2 id="options-heading" style="margin:0 0 8px 0;font-size:15px">Options</h2>
                    <div class="controls">
                        <label>
                            Difficulty:
                            <select id="difficulty" title="Choose difficulty">
                                <option value="very-easy">Very Easy — 1 op</option>
                                <option value="easy">Easy — 2 ops, no exponents</option>
                                <option value="medium">Medium — 3-4 ops, may include parentheses</option>
                                <option value="hard">Hard — 4-6 ops, exponents & nested parentheses</option>
                                <option value="expert">Expert — 6-8 ops, heavy nesting & exponents</option>
                            </select>
                        </label>
                        <label>
                            Number range:
                            <select id="range">
                                <option value="9">0–9</option>
                                <option value="19">-10–19</option>
                                <option value="49">-20–49</option>
                            </select>
                        </label>
                        <label>
                            Problems:
                            <input id="count" type="number" min="1" max="20" value="10" style="width:76px" />
                        </label>
                        <label>
                            Theme:
                            <select id="theme-select">
                                <option value="light">Light</option>
                                <option value="dark">Dark</option>
                                <option value="high-contrast">High Contrast</option>
                            </select>
                        </label>
                        <label>
                            <button class="secondary" id="reset-mastery" title="Reset mastery">Reset mastery</button>
                        </label>
                        <label>
                            <button class="secondary" id="reset-badges" title="Reset earned badges">Reset
                                badges</button>
                        </label>
                        <label>
                            <button class="secondary" id="export-badges" title="Export badges">Export badges</button>
                        </label>
                        <!-- Import removed to simplify teacher workflow; use Export to save a copy -->
                        <button id="generate">Start</button>
                        <button class="secondary" id="show-mnemonic" title="Quick help">Show PEMDAS</button>
                    </div>
                </section>

                <section class="card" aria-live="polite">
                    <div class="meta">
                        <div class="score">Score: <strong id="score">0</strong>/<span id="asked">0</span></div>
                        <div id="mastery" class="score" style="margin-left:12px">Mastery: <span
                                id="mastery-val">—</span></div>
                        <div id="progress" style="color:var(--muted)">Ready</div>
                    </div>

                    <div id="exercise" style="margin-top:12px">
                        <div style="display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap">
                            <div style="flex:1;min-width:220px">
                                <div class="problem" id="problem">Click Start to begin a set of problems.</div>
                            </div>
                            <div id="badges" class="badges" aria-hidden="false"></div>
                        </div>

                        <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
                            <label style="margin:0">
                                Your answer:
                                <input id="answer" inputmode="numeric"
                                    style="padding:8px;border-radius:8px;border:1px solid #d1d5db;width:160px;margin-left:8px" />
                            </label>
                            <button id="check">Check</button>
                            <button class="secondary" id="next">Skip / Next</button>
                            <label style="margin-left:auto;color:var(--muted)">
                                Show steps:
                                <input id="steps-toggle" type="checkbox" style="margin-left:6px" />
                            </label>
                        </div>

                        <div id="feedback" class="feedback" aria-live="polite"></div>
                        <pre id="steps" class="steps" style="display:none"></pre>
                    </div>
                </section>

                <section class="card" aria-labelledby="resources-heading">
                    <h2 id="resources-heading" style="margin:0 0 8px 0;font-size:15px">Resources</h2>
                    <div style="color:var(--muted);font-size:14px">
                        <ul style="margin:0 0 8px 18px">
                            <li><a href="https://www.w3schools.com/python/python_operators_precedence.asp"
                                    target="_blank" rel="noopener">Python operator precedence — W3Schools</a></li>
                            <li><a href="https://runestone.academy/ns/books/published/fopp/Conditionals/PrecedenceofOperators.html"
                                    target="_blank" rel="noopener">Precedence of Operators — Runestone</a></li>
                        </ul>

                        <div style="margin-top:8px">
                            <div
                                style="max-width:720px;margin:0 auto;position:relative;padding-bottom:56.25%;height:0;overflow:hidden;border-radius:8px">
                                <iframe src="https://www.youtube.com/embed/nD1xTpJo4jU?si=trz2yNi4ohEjsO_V"
                                    title="Order of Operations video" frameborder="0"
                                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                    allowfullscreen
                                    style="position:absolute;top:0;left:0;width:100%;height:100%;"></iframe>
                            </div>
                            <div style="font-size:13px;color:var(--muted);margin-top:6px">Video: brief overview of order
                                of
                                operations.</div>
                        </div>
                    </div>
                </section>

                <footer class="card" style="text-align:left">
                    Tips: Work inside parentheses first, then exponents, then multiplication/division left-to-right,
                    then
                    addition/subtraction left-to-right. Use the "Show steps" checkbox to see a step-by-step breakdown.
                </footer>
            </main>

            <aside class="sidebar">
                <section class="card" aria-labelledby="badges-heading">
                    <h2 id="badges-heading" style="margin:0 0 8px 0;font-size:15px">Badge cabinet</h2>
                    <div style="color:var(--muted);font-size:14px">
                        <div style="margin-bottom:8px">Earn badges by achieving mastery in each difficulty. Badges
                            persist in
                            your browser.</div>
                        <div id="badge-cabinet" class="cabinet" aria-live="polite"></div>
                        <!-- Hidden ARIA-live summary for programmatic announcements -->
                        <div id="badge-aria-live" class="sr-only" aria-live="polite" aria-atomic="true"></div>
                        <!-- Modal for badge details -->
                        <div id="badge-modal" class="modal-backdrop" style="display:none" aria-hidden="true">
                            <div class="modal" role="dialog" aria-modal="true" aria-labelledby="badge-modal-title">
                                <div style="display:flex;align-items:center;gap:12px">
                                    <div class="pixel-art" id="modal-art" aria-hidden="true"></div>
                                    <div style="flex:1">
                                        <h3 id="badge-modal-title">Badge</h3>
                                        <div id="badge-modal-desc" class="meta">Details about this badge.</div>
                                    </div>
                                    <button id="badge-modal-close" class="close" aria-label="Close">✖</button>
                                </div>
                                <div style="margin-top:12px">
                                    <div id="badge-modal-tips" style="font-size:13px;color:var(--muted)"></div>
                                    <div style="margin-top:12px;display:flex;gap:8px;align-items:center">
                                        <button id="badge-modal-export" class="secondary"
                                            title="Export badges and mastery">Export badges</button>
                                        <button id="badge-modal-close-text" class="close"
                                            aria-label="Close">Close</button>
                                        <div style="margin-left:auto;color:var(--muted);font-size:12px">Tip: Press Esc
                                            to close
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div style="margin-top:8px;font-size:13px;color:var(--muted)">Tip: Reach 80% correct over the
                            last 10
                            attempts to earn a badge.</div>
                    </div>
                </section>

                <section class="card" aria-labelledby="legend-heading">
                    <h2 id="legend-heading" style="margin:0 0 8px 0;font-size:15px">Operator legend</h2>
                    <div style="font-size:14px;color:var(--muted);">
                        <div
                            style="font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; display:flex; gap:16px; flex-wrap:wrap">
                            <div><strong>+</strong> addition</div>
                            <div><strong>-</strong> subtraction</div>
                            <div><strong>*</strong> multiplication</div>
                            <div><strong>/</strong> division</div>
                            <div><strong>**</strong> exponent (power)</div>
                        </div>
                        <div style="margin-top:8px;color:var(--muted);font-size:13px">Tip: Problems use Python-style
                            operators;
                            exponents use <code>**</code>. Order follows PEMDAS.</div>
                        <div style="margin-top:10px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace">
                            <div style="font-size:13px;color:var(--muted);margin-bottom:6px">Examples by difficulty:
                            </div>
                            <ul
                                style="margin:0;padding-left:18px;color:var(--muted);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, monospace">
                                <li><strong>Very Easy:</strong> <code>3 + 4</code></li>
                                <li><strong>Easy:</strong> <code>(5 + 2) * 3</code></li>
                                <li><strong>Medium:</strong> <code>(2 + 3) ** 2 - 4</code></li>
                                <li><strong>Hard:</strong> <code>(3 + (2 * 5)) ** 2 / 4</code></li>
                                <li><strong>Expert:</strong> <code>((2 + 3) ** (1 + 1)) * (4 - 1)</code></li>
                            </ul>
                        </div>
                    </div>
                </section>
            </aside>
        </div>
    </div>

    <script>
        // GitHub Copilot
        (function () {
            'use strict';
            const el = id => document.getElementById(id);
            const difficulty = el('difficulty');
            const rngSelect = el('range');
            const themeSelect = el('theme-select');
            const generateBtn = el('generate');
            const countInput = el('count');
            const problemEl = el('problem');
            const badgesEl = el('badges');
            const answerInput = el('answer');
            const checkBtn = el('check');
            const nextBtn = el('next');
            const scoreEl = el('score');
            const askedEl = el('asked');
            const progressEl = el('progress');
            const stepsEl = el('steps');
            const stepsToggle = el('steps-toggle');
            const feedbackEl = el('feedback');
            const showMn = el('show-mnemonic');
            const masteryValEl = el('mastery-val');
            const resetMasteryBtn = el('reset-mastery');

            let problems = [];
            let index = 0;
            let score = 0;
            let total = 0;

            function randInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

            function generateExpression(level, maxAbs) {
                // build tokens with numbers and operators, possibly parentheses and exponents
                const opsBasic = ['+', '-', '*', '/'];
                const opsWithExp = ['+', '-', '*', '/', '**'];
                // Enable exponents for all levels; presence controlled by random operator picks
                const ops = opsWithExp; // include '**' in all difficulty sets

                // determine number of operations
                let opsCount;
                if (level === 'very-easy') opsCount = 1;
                else if (level === 'easy') opsCount = 2;
                else if (level === 'medium') opsCount = randInt(3, 4);
                else if (level === 'hard') opsCount = randInt(4, 6);
                else if (level === 'expert') opsCount = randInt(6, 8);
                else opsCount = 2;

                // produce a flat expression first
                let tokens = [];
                // chance to include exponent operator varies by difficulty (rarer for easier levels)
                const includeExpChance = level === 'very-easy' ? 0.10 : level === 'easy' ? 0.25 : level === 'medium' ? 0.5 : level === 'hard' ? 0.75 : 0.9;
                for (let i = 0; i <= opsCount; i++) {
                    let n = randInt(-maxAbs, maxAbs);
                    // avoid zero in denominators later by ensuring possibility
                    tokens.push(String(n));
                    if (i < opsCount) {
                        // pick operator: prefer basic operators, include '**' probabilistically
                        let op;
                        if (Math.random() < includeExpChance) op = '**';
                        else op = pick(opsBasic);
                        tokens.push(op);
                    }
                }

                // optionally insert parentheses pairs (allow at every level; easier levels get fewer pairs)
                {
                    let pairs = 0;
                    if (level === 'very-easy') pairs = randInt(0, 1);
                    else if (level === 'easy') pairs = randInt(0, 1);
                    else if (level === 'medium') pairs = randInt(0, 1);
                    else if (level === 'hard') pairs = randInt(1, 2);
                    else if (level === 'expert') pairs = randInt(2, 3);
                    // do not add parentheses if expression is a single operation
                    if (opsCount < 2) pairs = 0;
                    for (let p = 0; p < pairs; p++) {
                        // choose positions that encompass at least one operator
                        const len = tokens.length;
                        if (len < 3) break;
                        let i = randInt(0, Math.max(0, len - 3));
                        // ensure i is number position (even index), start at even index
                        if (i % 2 === 1) i++;
                        let j = randInt(i + 2, Math.min(len - 1, i + 6));
                        if (j % 2 === 1) j++;
                        // wrap tokens i..j inclusive in parentheses
                        tokens.splice(i, 0, '(');
                        // j shifts by +1 due to insertion
                        tokens.splice(j + 1, 0, ')');
                    }
                }

                // Clamp exponents to small magnitudes to avoid huge numeric results.
                // Find any '**' operators and ensure the exponent is a small non-negative integer (0..4)
                const findNextNumber = (arr, start) => {
                    for (let i = start + 1; i < arr.length; i++) {
                        if (/^-?\d+$/.test(arr[i])) return i;
                    }
                    return -1;
                };
                const findPrevNumber = (arr, start) => {
                    for (let i = start - 1; i >= 0; i--) {
                        if (/^-?\d+$/.test(arr[i])) return i;
                    }
                    return -1;
                };
                for (let i = 0; i < tokens.length; i++) {
                    if (tokens[i] === '**') {
                        const expIdx = findNextNumber(tokens, i);
                        const baseIdx = findPrevNumber(tokens, i);
                        if (expIdx !== -1) {
                            // force small non-negative exponent
                            tokens[expIdx] = String(randInt(0, 4));
                        }
                        if (baseIdx !== -1) {
                            // keep base modest to avoid huge powers
                            let base = parseInt(tokens[baseIdx], 10) || 1;
                            if (base > 6) base = 6;
                            if (base < -6) base = -6;
                            tokens[baseIdx] = String(base);
                        }
                    }
                }

                // replace some multiplies by implicit? Keep explicit.
                // Clean up: avoid sequences like (/ 0) - later evaluator handles divide by zero by regenerating
                const expr = tokens.join(' ');
                if (/\/\s*0(?!\d|\.|\))/g.test(expr)) {
                    return generateExpression(level, maxAbs); // regenerate to avoid immediate division by zero
                }
                return expr;
            }

            // Evaluate an expression string safely for our generated expressions.
            // Supports ** (Python) or ^ as exponent token and normal arithmetic. Returns Number.
            function evaluateExpr(expr) {
                // sanitize: only allow digits, spaces, operators, parentheses, decimal point and minus
                if (!/^[0-9+\-*/^().\s]+$/.test(expr)) throw new Error('Invalid expression characters');
                const jsExpr = expr.replace(/\^/g, '**');
                // use Function for speed; surrounded to avoid eval scope issues
                // handle potential division by zero -> throw
                try {
                    const val = Function('"use strict"; return (' + jsExpr + ')')();
                    if (!isFinite(val)) throw new Error('Non-finite result');
                    // round to reasonable precision to avoid floating noise
                    return Math.round((val + Number.EPSILON) * 100000) / 100000;
                } catch (e) {
                    throw e;
                }
            }

            // Produce step-by-step reduction following PEMDAS-like stages.
            function stepsFor(expr) {
                let s = expr.replace(/\s+/g, ' ').trim();
                const steps = [s];
                // helper to compute one-level (no parentheses) step using precedence
                function computeFlat(str) {
                    str = str.trim();
                    // convert ^ to ** in this internal process; we'll use JS eval for paired numbers in simple matches
                    // Evaluate exponent first (right associative). We'll choose right-most ** for correctness.
                    // Step function finds next operation by precedence and computes one operation, returning new string.
                    // Remove outer + unary issues by ensuring tokens separated by spaces.
                    // Normalize spaces
                    str = str.replace(/\s+/g, ' ');
                    // convert unary pluses to explicit (we use patterns that find binary ops)
                    // Evaluate exponent (right-most)
                    const exponentRegex = /(-?\d+(\.\d+)?|\)\s*)(\s*\^\s*)(-?\d+(\.\d+)?|\()/;
                    // Simpler approach: replace ^ by ** for eval and use a regex to find one operation pair for **, then */ then +-.
                    const js = str.replace(/\^/g, '**');

                    // helper to apply regex and replace first match
                    const applyOpRegex = (regex) => {
                        const m = regex.exec(js);
                        if (!m) return null;
                        // compute match range in original str by matching using the same subpattern adapted to original
                        return null;
                    };

                    // Simpler safer approach: use a small parser loop:
                    // 1) Tokenize numbers, operators, parentheses (we assume no parentheses here)
                    const tok = [];
                    const pattern = /(-?\d+(\.\d+)?|\*\*|[+\-*/^()])/g;
                    let match;
                    while ((match = pattern.exec(str)) !== null) {
                        tok.push(match[0]);
                    }
                    // handle exponent '**' which we don't have in tokens (we used ^), so convert ^ to '**' in tokens:
                    for (let i = 0; i < tok.length; i++) if (tok[i] === '^') tok[i] = '**';

                    // precedence order arrays
                    const precedence = [['**'], ['*', '/'], ['+', '-']];
                    // find next operation index by scanning precedence
                    for (const ops of precedence) {
                        // for exponent, right-to-left
                        if (ops.includes('**')) {
                            for (let i = tok.length - 1; i >= 0; i--) {
                                if (ops.includes(tok[i])) {
                                    // compute tok[i-1] op tok[i+1]
                                    const a = parseFloat(tok[i - 1]);
                                    const b = parseFloat(tok[i + 1]);
                                    let res = 0;
                                    if (tok[i] === '**') res = Math.pow(a, b);
                                    else if (tok[i] === '*') res = a * b;
                                    else if (tok[i] === '/') res = a / b;
                                    else if (tok[i] === '+') res = a + b;
                                    else if (tok[i] === '-') res = a - b;
                                    // replace three tokens
                                    tok.splice(i - 1, 3, String(Math.round((res + Number.EPSILON) * 100000) / 100000));
                                    const out = tok.join(' ');
                                    return out;
                                }
                            }
                        } else {
                            for (let i = 0; i < tok.length; i++) {
                                if (ops.includes(tok[i])) {
                                    const a = parseFloat(tok[i - 1]);
                                    const b = parseFloat(tok[i + 1]);
                                    let res;
                                    if (tok[i] === '*') res = a * b;
                                    else if (tok[i] === '/') res = a / b;
                                    else if (tok[i] === '+') res = a + b;
                                    else if (tok[i] === '-') res = a - b;
                                    tok.splice(i - 1, 3, String(Math.round((res + Number.EPSILON) * 100000) / 100000));
                                    return tok.join(' ');
                                }
                            }
                        }
                    }
                    return str;
                }

                try {

                    // Close modal on backdrop click or Escape key, restore focus
                    (function () {
                        const modal = document.getElementById('badge-modal');
                        if (!modal) return;
                        // backdrop click closes when clicking outside inner dialog
                        modal.addEventListener('click', (ev) => {
                            if (ev.target === modal) closeModal();
                        });
                        const closeBtn = document.getElementById('badge-modal-close');
                        if (closeBtn) closeBtn.addEventListener('click', closeModal);
                        // text-style close button in modal (added for clarity)
                        const closeTextBtn = document.getElementById('badge-modal-close-text');
                        if (closeTextBtn) closeTextBtn.addEventListener('click', closeModal);
                        // modal export connects to the main export button if present
                        const modalExport = document.getElementById('badge-modal-export');
                        if (modalExport) modalExport.addEventListener('click', () => {
                            // If a badge modal is open, download that badge as an image.
                            const modal = document.getElementById('badge-modal');
                            const openLvl = modal && modal._openLevel;
                            if (openLvl) {
                                downloadBadgeImage(openLvl);
                            } else {
                                const primary = document.getElementById('export-badges');
                                if (primary) primary.click();
                            }
                        });
                        document.addEventListener('keydown', (ev) => {
                            if (ev.key === 'Escape') {
                                if (modal.style.display !== 'none') {
                                    closeModal();
                                }
                            }
                        });
                    })();
                    // Handle parentheses iteratively
                    while (/\(/.test(s)) {
                        // find innermost parenthetical group
                        const inner = s.match(/\([^()]*\)/);
                        if (!inner) break;
                        const group = inner[0];
                        const innerContent = group.slice(1, -1);
                        // compute inner stepwise until it's a single number
                        let cur = innerContent;
                        while (!/^[-]?\d+(\.\d+)?$/.test(cur)) {
                            const next = computeFlat(cur);
                            if (!next || next === cur) break;
                            cur = next;
                            steps.push(s.replace(group, '(' + cur + ')'));
                        }
                        // replace the entire parenthesis with computed value
                        s = s.replace(group, cur);
                        steps.push(s);
                    }
                    // Now no parentheses: reduce flat
                    while (!/^[-]?\d+(\.\d+)?$/.test(s)) {
                        const next = computeFlat(s);
                        if (!next || next === s) break;
                        s = next;
                        steps.push(s);
                    }
                } catch (e) {
                    // fallback: single evaluation step if something unexpected
                    steps.push('= ' + evaluateExpr(expr));
                }
                return steps;
            }

            function newSet() {
                const level = difficulty.value;
                const maxAbs = parseInt(rngSelect.value, 10);
                const count = Math.min(20, Math.max(1, parseInt(countInput.value, 10) || 10));
                problems = [];
                index = 0;
                score = 0;
                total = count;
                for (let i = 0; i < count; i++) {
                    // ensure valid evaluated numbers and avoid division by zero artifacts
                    let ex;
                    let val;
                    let attempt = 0;
                    do {
                        ex = generateExpression(level, maxAbs);
                        try { val = evaluateExpr(ex); }
                        catch (err) { val = null; }
                        attempt++;
                        if (attempt > 50) break;
                    } while (val === null || !isFinite(val) || Math.abs(val) > 1e6);
                    // if we failed to produce a valid value after many attempts, try again without counting this iteration
                    if (val === null || !isFinite(val) || Math.abs(val) > 1e6) {
                        i--; // retry this index
                        continue;
                    }
                    problems.push({ expr: ex, answer: val, level });
                }
                scoreEl.textContent = '0';
                askedEl.textContent = '0';
                progressEl.textContent = `Set: ${count} problems (${level})`;
                // Enable inputs for a fresh set
                try { if (nextBtn) nextBtn.disabled = false; } catch (e) { }
                try { if (checkBtn) checkBtn.disabled = false; } catch (e) { }
                try { if (answerInput) answerInput.disabled = false; } catch (e) { }
                showProblem(0);
            }

            // Mastery tracking: rolling window per difficulty (last N attempts)
            const MASTERY_WINDOW = 10;
            const MASTERY_THRESHOLD = 0.8; // 80% correct to gain mastery

            // Badge storage (earned trophies per difficulty)
            const BADGE_KEY = 'ooo_badges';

            // Retro arcade-themed names for levels
            const ARCADE_NAMES = {
                'very-easy': '1-UP Rookie',
                'easy': 'Pixel Player',
                'medium': 'Combo Champ',
                'hard': 'Boss Brawler',
                'expert': 'High Score Legend'
            };
            const ARCADE_ABBR = {
                'very-easy': '1UP',
                'easy': 'PX',
                'medium': 'CC',
                'hard': 'BB',
                'expert': 'HS'
            };

            // Per-level badge color palette: [bg1, bg2, text]
            const BADGE_COLORS = {
                'very-easy': ['#ffde59', '#f29f05', '#111'],
                'easy': ['#6be3ff', '#00bcd4', '#001a30'],
                'medium': ['#c0ffc8', '#4caf50', '#001a30'],
                'hard': ['#ff99cc', '#ff4081', '#001a30'],
                'expert': ['#ffd6a5', '#ff6b00', '#001a30']
            };

            function loadBadges() {
                try {
                    const raw = localStorage.getItem(BADGE_KEY);
                    return raw ? JSON.parse(raw) : {};
                } catch (e) { return {}; }
            }

            function saveBadges(b) {
                try { localStorage.setItem(BADGE_KEY, JSON.stringify(b)); } catch (e) { }
            }

            function awardBadge(level) {
                const b = loadBadges();
                if (!b[level] || !b[level].earned) {
                    b[level] = { earned: true, earnedAt: new Date().toISOString() };
                    saveBadges(b);
                    // toast and update UI
                    showBadgeToast(level);
                    updateBadgeCabinet();
                }
            }

            function clearBadges() { try { localStorage.removeItem(BADGE_KEY); } catch (e) { } updateBadgeCabinet(); }

            function getBadgeInfo(level) {
                const b = loadBadges();
                return b[level] || { earned: false };
            }

            function updateBadgeCabinet() {
                const cabinet = document.getElementById('badge-cabinet');
                if (!cabinet) return;
                cabinet.innerHTML = '';
                const levels = ['very-easy', 'easy', 'medium', 'hard', 'expert'];
                levels.forEach(lv => {
                    const info = getBadgeInfo(lv);
                    const el = document.createElement('div');
                    el.className = 'badge trophy ' + (info.earned ? 'earned' : 'locked');
                    const arcadeName = ARCADE_NAMES[lv] || lv.split('-').map(w => w[0].toUpperCase() + w.slice(1)).join(' ');
                    const abbr = ARCADE_ABBR[lv] || lv.split('-').map(w => w[0].toUpperCase()).join('');
                    el.title = arcadeName;
                    el.setAttribute('data-level', lv);
                    el.setAttribute('tabindex', '0');
                    el.setAttribute('role', 'button');
                    // build inner content: icon + abbrev
                    const icon = document.createElement('span');
                    icon.className = 'icon';
                    // inline pixel-style SVG
                    // use currentColor so SVG icons tint to the badge's color
                    icon.innerHTML = info.earned ? `
                                                <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                                    <circle cx="8" cy="6" r="3" fill="currentColor" />
                                                    <rect x="4" y="11" width="8" height="2" fill="currentColor" />
                                                </svg>` : `
                                                <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                                    <rect x="4" y="4" width="8" height="2" fill="currentColor" />
                                                    <rect x="4" y="8" width="8" height="2" fill="currentColor" />
                                                </svg>`;
                    el.appendChild(icon);
                    const text = document.createElement('span');
                    text.textContent = abbr;
                    el.appendChild(text);
                    if (info.earned && info.earnedAt) {
                        const d = new Date(info.earnedAt);
                        const ts = d.toLocaleString();
                        el.setAttribute('aria-label', `${arcadeName} badge earned ${ts}`);
                        el.setAttribute('title', `${arcadeName} — earned ${ts}`);
                    } else {
                        el.setAttribute('aria-label', `${arcadeName} badge locked`);
                        el.setAttribute('title', `${arcadeName} — locked`);
                    }
                    // apply per-level color variables for earned badges
                    try {
                        const pal = BADGE_COLORS[lv];
                        if (info.earned && pal) {
                            el.style.setProperty('--badge-bg1', pal[0]);
                            el.style.setProperty('--badge-bg2', pal[1]);
                            el.style.setProperty('--badge-text', pal[2] || '#111');
                        } else {
                            // ensure locked look (use default locked vars)
                            el.style.setProperty('--badge-locked-1', '#e6e6e6');
                            el.style.setProperty('--badge-locked-2', '#cfcfcf');
                            el.style.setProperty('--badge-locked-text', '#6b6b6b');
                        }
                    } catch (e) { }
                    cabinet.appendChild(el);
                });
                // announce summary
                const live = document.getElementById('badge-aria-live');
                if (live) {
                    const earned = levels.filter(l => getBadgeInfo(l).earned).length;
                    live.textContent = `${earned} badge${earned === 1 ? '' : 's'} earned.`;
                }
                // update modal art if open
                const modal = document.getElementById('badge-modal');
                if (modal && modal.style.display !== 'none') {
                    const openLvl = modal._openLevel;
                    if (openLvl) populateModal(openLvl);
                }
            }

            // Populate and show badge detail modal
            function populateModal(level) {
                const modal = document.getElementById('badge-modal');
                const art = document.getElementById('modal-art');
                const title = document.getElementById('badge-modal-title');
                const desc = document.getElementById('badge-modal-desc');
                const tips = document.getElementById('badge-modal-tips');
                if (!modal || !art || !title || !desc || !tips) return;
                const info = getBadgeInfo(level);
                const name = ARCADE_NAMES[level] || level;
                title.textContent = name;
                if (info.earned && info.earnedAt) {
                    const d = new Date(info.earnedAt);
                    desc.textContent = `Earned: ${d.toLocaleString()}`;
                } else {
                    desc.textContent = 'Not yet earned.';
                }
                // tips and encouragement
                const tipMap = {
                    'very-easy': 'Practice basics: add and subtract mentally to build speed.',
                    'easy': 'Watch for order: parentheses change the evaluation order.',
                    'medium': 'Exponents appear more often; compute powers carefully.',
                    'hard': 'Work inner parentheses first and simplify step-by-step.',
                    'expert': 'Mix of nested parentheses and exponents — take it slow.'
                };
                tips.textContent = tipMap[level] || 'Good work — keep practicing!';

                // pixel art (larger) per badge
                const artSVG = {
                    'very-easy': `<svg width="64" height="64" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="64" height="64" fill="#111"/><rect x="8" y="8" width="48" height="48" fill="#ffd24a"/><rect x="20" y="20" width="24" height="24" fill="#ff8c00"/></svg>`,
                    'easy': `<svg width="64" height="64" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="64" height="64" fill="#0b1630"/><rect x="10" y="12" width="44" height="40" fill="#6be3ff"/><rect x="18" y="20" width="28" height="24" fill="#00bcd4"/></svg>`,
                    'medium': `<svg width="64" height="64" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="64" height="64" fill="#07112a"/><rect x="8" y="8" width="48" height="48" fill="#c0ffc8"/><rect x="18" y="18" width="28" height="28" fill="#4caf50"/></svg>`,
                    'hard': `<svg width="64" height="64" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="64" height="64" fill="#2a0014"/><rect x="6" y="10" width="52" height="44" fill="#ff99cc"/><rect x="14" y="18" width="36" height="28" fill="#ff4081"/></svg>`,
                    'expert': `<svg width="64" height="64" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><rect width="64" height="64" fill="#001a1a"/><rect x="8" y="8" width="48" height="48" fill="#ffd6a5"/><rect x="16" y="16" width="32" height="32" fill="#ff6b00"/></svg>`
                };
                art.innerHTML = artSVG[level] || artSVG['medium'];

                // store open level and show modal
                modal._openLevel = level;
                // remember last focused element to restore later
                modal._lastFocus = document.activeElement;
                modal.style.display = 'flex';
                modal.setAttribute('aria-hidden', 'false');
                // focus management: move focus to close button
                const close = document.getElementById('badge-modal-close');
                if (close) setTimeout(() => close.focus(), 10);

                // install a small focus-trap: keep Tab/Shift+Tab cycling inside the modal
                try {
                    // remove any existing handler first
                    if (modal._trapHandler) document.removeEventListener('keydown', modal._trapHandler);
                    modal._trapHandler = function (ev) {
                        if (ev.key !== 'Tab') return;
                        // find focusable elements within the modal dialog
                        const focusable = Array.from(modal.querySelectorAll('.modal button, .modal [href], .modal input, .modal select, .modal textarea, .modal [tabindex]:not([tabindex="-1"])'))
                            .filter(el => !el.hasAttribute('disabled') && el.offsetParent !== null);
                        if (!focusable.length) return;
                        const first = focusable[0];
                        const last = focusable[focusable.length - 1];
                        const active = document.activeElement;
                        if (!ev.shiftKey && active === last) {
                            ev.preventDefault();
                            first.focus();
                        } else if (ev.shiftKey && active === first) {
                            ev.preventDefault();
                            last.focus();
                        }
                    };
                    document.addEventListener('keydown', modal._trapHandler);
                } catch (e) { /* ignore */ }
            }

            function closeModal() {
                const modal = document.getElementById('badge-modal');
                if (!modal) return;
                modal.style.display = 'none';
                modal.setAttribute('aria-hidden', 'true');
                modal._openLevel = null;
                try { if (modal._lastFocus && typeof modal._lastFocus.focus === 'function') modal._lastFocus.focus(); } catch (e) { }
                // remove focus trap handler if installed
                try { if (modal._trapHandler) { document.removeEventListener('keydown', modal._trapHandler); modal._trapHandler = null; } } catch (e) { }
            }

            // Toast stack + ARIA-live announcement
            function _appendToastElement(message) {
                const stack = document.getElementById('toast-stack') || (() => {
                    const el = document.createElement('div'); el.id = 'toast-stack'; document.body.appendChild(el); return el;
                })();
                const t = document.createElement('div');
                t.className = 'toast';
                t.setAttribute('role', 'status');
                t.textContent = message;
                stack.appendChild(t);
                // auto-remove after timeout, fade out
                setTimeout(() => { t.style.transition = 'opacity 300ms'; t.style.opacity = '0'; }, 2200);
                setTimeout(() => { try { stack.removeChild(t); } catch (e) { } }, 2600);
            }

            function showLiveToast(message) {
                try {
                    const live = document.getElementById('badge-aria-live');
                    if (live) live.textContent = message;
                    _appendToastElement(message);
                } catch (e) { /* ignore */ }
            }

            function showBadgeToast(level) {
                const name = ARCADE_NAMES[level] || level.split('-').map(w => w[0].toUpperCase() + w.slice(1)).join(' ');
                showLiveToast(`Badge earned: ${name} 🎖 — view in the Badge cabinet`);
            }

            function loadMastery() {
                try {
                    const raw = localStorage.getItem('ooo_mastery');
                    return raw ? JSON.parse(raw) : {};
                } catch (e) { return {}; }
            }
            function saveMastery(m) {
                try { localStorage.setItem('ooo_mastery', JSON.stringify(m)); } catch (e) { }
            }

            function recordAttempt(level, correct) {
                const m = loadMastery();
                if (!m[level]) m[level] = { recent: [], achieved: false, achievedAt: null };
                const arr = m[level].recent;
                arr.push(correct ? 1 : 0);
                if (arr.length > MASTERY_WINDOW) arr.shift();
                const sum = arr.reduce((a, b) => a + b, 0);
                const pct = arr.length ? (sum / arr.length) : 0;
                if (!m[level].achieved && arr.length >= MASTERY_WINDOW && pct >= MASTERY_THRESHOLD) {
                    m[level].achieved = true;
                    m[level].achievedAt = new Date().toISOString();
                    // award a persistent badge and notify user (non-blocking) using arcade-themed name
                    try { awardBadge(level); } catch (e) { }
                    try { const arcade = ARCADE_NAMES[level] || level.replace('-', ' '); showLiveToast(`Mastery achieved — ${arcade}! 🎉 A badge was awarded.`); } catch (e) { }
                }
                saveMastery(m);
                return { pct: Math.round(pct * 100), count: arr.length, achieved: m[level].achieved };
            }

            function getMasteryDisplay(level) {
                const m = loadMastery();
                const data = m[level] || { recent: [], achieved: false };
                const arr = data.recent || [];
                const sum = arr.reduce((a, b) => a + b, 0);
                const pct = arr.length ? Math.round((sum / arr.length) * 100) : 0;
                return { pct, count: arr.length, achieved: !!data.achieved };
            }

            function updateMasteryUI(level, precomputed) {
                if (!masteryValEl) return;
                const info = precomputed || getMasteryDisplay(level);
                if (!info || !info.count) {
                    masteryValEl.textContent = `0% (0/${MASTERY_WINDOW})`;
                } else {
                    masteryValEl.textContent = `${info.pct}% (${info.count}/${MASTERY_WINDOW})`;
                }
                if (info && info.achieved) masteryValEl.textContent += ' ✓';
            }

            if (resetMasteryBtn) resetMasteryBtn.addEventListener('click', () => {
                try { localStorage.removeItem('ooo_mastery'); } catch (e) { }
                updateMasteryUI(difficulty.value);
            });

            const resetBadgesBtn = document.getElementById('reset-badges');
            if (resetBadgesBtn) resetBadgesBtn.addEventListener('click', () => {
                if (!confirm('Clear all earned badges from this browser?')) return;
                clearBadges();
                showLiveToast('All badges cleared.');
            });

            // Export badges (import UI removed)
            const exportBadgesBtn = document.getElementById('export-badges');
            if (exportBadgesBtn) exportBadgesBtn.addEventListener('click', () => {
                try {
                    const badges = loadBadges();
                    const mastery = loadMastery();
                    const payload = { badges: badges, mastery: mastery };
                    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    // timestamped filename: ooo_badges-YYYYMMDD-HHMMSS.json
                    const now = new Date();
                    const y = now.getFullYear();
                    const mm = String(now.getMonth() + 1).padStart(2, '0');
                    const d = String(now.getDate()).padStart(2, '0');
                    const hh = String(now.getHours()).padStart(2, '0');
                    const min = String(now.getMinutes()).padStart(2, '0');
                    const ss = String(now.getSeconds()).padStart(2, '0');
                    a.download = `ooo_export-${y}${mm}${d}-${hh}${min}${ss}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    showLiveToast('Badges and mastery exported.');
                } catch (e) { showLiveToast('Export failed.'); }
            });
            // Convert the inline SVG shown in the badge modal into a PNG and download it.
            function downloadBadgeImage(level) {
                try {
                    const artEl = document.getElementById('modal-art');
                    if (!artEl) return showLiveToast('Badge image not available.');
                    const svgEl = artEl.querySelector('svg');
                    if (!svgEl) return showLiveToast('Badge image not available.');
                    // Serialize SVG
                    const svgText = svgEl.outerHTML;
                    const svgData = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgText);
                    const img = new Image();
                    img.onload = function () {
                        // scale up for a nicer PNG
                        const scale = 4;
                        const w = img.width * scale;
                        const h = img.height * scale;
                        const canvas = document.createElement('canvas');
                        canvas.width = w;
                        canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        // Fill transparent background (keeps SVG colors)
                        ctx.clearRect(0, 0, w, h);
                        ctx.drawImage(img, 0, 0, w, h);
                        canvas.toBlob(function (blob) {
                            if (!blob) { showLiveToast('Failed to create image.'); return; }
                            const a = document.createElement('a');
                            const now = new Date();
                            const y = now.getFullYear();
                            const mm = String(now.getMonth() + 1).padStart(2, '0');
                            const d = String(now.getDate()).padStart(2, '0');
                            const hh = String(now.getHours()).padStart(2, '0');
                            const min = String(now.getMinutes()).padStart(2, '0');
                            const ss = String(now.getSeconds()).padStart(2, '0');
                            a.href = URL.createObjectURL(blob);
                            a.download = `ooo_badge-${level}-${y}${mm}${d}-${hh}${min}${ss}.png`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(a.href);
                            showLiveToast('Badge image downloaded.');
                        }, 'image/png');
                    };
                    img.onerror = function () { showLiveToast('Failed to render badge image.'); };
                    img.src = svgData;
                } catch (e) {
                    showLiveToast('Failed to export badge image.');
                }
            }
            // Import functionality removed from UI — import code intentionally omitted to avoid accidental overwrites.

            // Theme handling: apply class to body and persist selection
            function applyTheme(theme) {
                document.body.classList.remove('theme-dark', 'theme-high-contrast');
                if (theme === 'dark') document.body.classList.add('theme-dark');
                if (theme === 'high-contrast') document.body.classList.add('theme-high-contrast');
                // update select value if present
                if (themeSelect) themeSelect.value = theme === 'light' ? 'light' : theme;
            }

            if (themeSelect) {
                themeSelect.addEventListener('change', (e) => {
                    const t = e.target.value;
                    applyTheme(t);
                    try { localStorage.setItem('ooo_theme', t); } catch (err) { }
                });
            }

            // initialize theme from localStorage or default to light
            try {
                const saved = localStorage.getItem('ooo_theme') || 'light';
                applyTheme(saved);
            } catch (err) { applyTheme('light'); }

            // initialize mastery display
            try { updateMasteryUI(difficulty.value); } catch (e) { }
            try { updateBadgeCabinet(); } catch (e) { }

            function showProblem(i) {
                if (i >= problems.length) {
                    problemEl.textContent = 'All done! Click Start to begin a new set.';
                    feedbackEl.textContent = `Final score: ${score} / ${total}`;
                    stepsEl.style.display = 'none';
                    progressEl.textContent = 'Finished';
                    // disable controls when finished
                    try { if (nextBtn) nextBtn.disabled = true; } catch (e) { }
                    try { if (checkBtn) checkBtn.disabled = true; } catch (e) { }
                    try { if (answerInput) answerInput.disabled = true; } catch (e) { }
                    return;
                }
                index = i;
                const p = problems[i];
                problemEl.textContent = p.expr;
                // ensure controls enabled for active problems
                try { if (nextBtn) nextBtn.disabled = false; } catch (e) { }
                try { if (checkBtn) checkBtn.disabled = false; } catch (e) { }
                try { if (answerInput) answerInput.disabled = false; } catch (e) { }
                // render badges indicating difficulty and contained features
                if (badgesEl) {
                    badgesEl.innerHTML = '';
                    const level = p.level || difficulty.value;
                    const make = (text, cls, iconSVG) => {
                        const s = document.createElement('span');
                        s.className = 'badge' + (cls ? ' ' + cls : '');
                        s.setAttribute('aria-hidden', 'true');
                        // icon (small inline SVG) then text
                        if (iconSVG) {
                            const wrap = document.createElement('span');
                            wrap.style.display = 'inline-flex';
                            wrap.style.alignItems = 'center';
                            wrap.style.gap = '6px';
                            wrap.innerHTML = iconSVG + `<span style="font-weight:600">${text}</span>`;
                            s.appendChild(wrap);
                        } else {
                            s.textContent = text;
                        }
                        return s;
                    };
                    // Difficulty badge (arcade-themed name)
                    const arcadeLabel = ARCADE_NAMES[level] || level.split('-').map(w => w[0].toUpperCase() + w.slice(1)).join(' ');
                    badgesEl.appendChild(make(arcadeLabel, 'secondary'));
                    // Feature badges
                    try {
                        const expr = p.expr || '';
                        if (/\*\*/.test(expr) || /\^/.test(expr)) badgesEl.appendChild(make('Exponent', '', `
                                                        <svg width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                                            <path fill="currentColor" d="M5 20v-2h14v2H5zm7-18l3 5h-2v6h-2V7H9l3-5z"/>
                                                        </svg>`));
                        if (/[()]/.test(expr)) badgesEl.appendChild(make('Parentheses', '', `
                                                        <svg width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                                            <path fill="currentColor" d="M9 4a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h.5v6H9a1 1 0 0 0-1 1v2a1 1 0 0 0 1 1h.5V4H9zm6 0v16h-.5a1 1 0 0 1-1-1v-2a1 1 0 0 1 1-1h.5V8H15a1 1 0 0 1-1-1V5a1 1 0 0 1 1-1h.5z"/>
                                                        </svg>`));
                        if (/\//.test(expr)) badgesEl.appendChild(make('Division', 'secondary', `
                                                        <svg width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                                            <path fill="currentColor" d="M7 4a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zm0 13a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3zM7 12h10v2H7z"/>
                                                        </svg>`));
                        if (/\*/.test(expr) && !/\*\*/.test(expr)) badgesEl.appendChild(make('Multiplication', 'secondary', `
                                                        <svg width="14" height="14" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                                                            <path fill="currentColor" d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/>
                                                        </svg>`));
                    } catch (e) { }
                }
                answerInput.value = '';
                feedbackEl.textContent = '';
                stepsEl.textContent = '';
                stepsEl.style.display = stepsToggle.checked ? 'block' : 'none';
                askedEl.textContent = i;
                // update mastery UI for this problem's level
                updateMasteryUI(p.level || difficulty.value);
                // ensure keyboard activation handlers on cabinet (event delegation)
                const cabinet = document.getElementById('badge-cabinet');
                if (cabinet && !cabinet._wired) {
                    cabinet._wired = true;
                    cabinet.addEventListener('click', (ev) => {
                        const tgt = ev.target.closest('.badge.trophy');
                        if (!tgt) return;
                        const lvl = tgt.getAttribute('data-level');
                        const info = getBadgeInfo(lvl);
                        const name = ARCADE_NAMES[lvl] || lvl;
                        if (info.earned) {
                            const d = new Date(info.earnedAt);
                            showLiveToast(`${name} badge earned ${d.toLocaleString()}`);
                        } else {
                            showLiveToast(`${name} badge locked`);
                        }
                        // open detail modal for this badge (accessible)
                        try { populateModal(lvl); } catch (e) { }
                    });
                    cabinet.addEventListener('keydown', (ev) => {
                        if (ev.key === 'Enter' || ev.key === ' ') {
                            const tgt = ev.target.closest('.badge.trophy');
                            if (!tgt) return;
                            ev.preventDefault();
                            tgt.click();
                        }
                    });
                }
            }

            checkBtn.addEventListener('click', () => {
                if (!problems.length) return;
                const p = problems[index];
                const user = answerInput.value.trim();
                if (user === '') { feedbackEl.textContent = 'Enter a numeric answer or press Skip/Next.'; return; }
                const userNum = Number(user);
                if (Number.isNaN(userNum)) { feedbackEl.textContent = 'Please enter a valid number.'; return; }
                let correct = false;
                // allow small tolerance
                const tol = 1e-4;
                if (Math.abs(userNum - p.answer) <= tol) correct = true;
                if (correct) {
                    score++;
                    feedbackEl.textContent = 'Correct! ✅ ' + p.expr + ' = ' + p.answer;
                } else {
                    feedbackEl.textContent = 'Not quite. ✖ Correct: ' + p.answer;
                }
                // record mastery attempt
                try { const res = recordAttempt(p.level || difficulty.value, correct); updateMasteryUI(p.level || difficulty.value, res); } catch (e) { }
                scoreEl.textContent = score;
                askedEl.textContent = index + 1;
                // show steps if requested
                if (stepsToggle.checked) {
                    try {
                        const st = stepsFor(p.expr);
                        stepsEl.style.display = 'block';
                        stepsEl.textContent = st.join('\n→ ');
                    } catch (e) {
                        stepsEl.style.display = 'none';
                    }
                }
            });

            nextBtn.addEventListener('click', () => {
                if (!problems.length) return;
                // mark as attempted
                askedEl.textContent = index + 1;
                // move to next
                // update mastery UI for this problem's level
                const p = problems[index];
                updateMasteryUI(p && p.level ? p.level : difficulty.value);
                showProblem(index + 1);
            });

            generateBtn.addEventListener('click', newSet);
            stepsToggle.addEventListener('change', () => {
                stepsEl.style.display = stepsToggle.checked ? 'block' : 'none';
                // if showing, precompute steps for current problem
                if (stepsToggle.checked && problems.length && problems[index]) {
                    try {
                        stepsEl.textContent = stepsFor(problems[index].expr).join('\n→ ');
                    } catch (e) { stepsEl.textContent = 'Cannot show steps for this expression.'; }
                }
            });

            showMn.addEventListener('click', () => {
                showLiveToast('PEMDAS: Parentheses, Exponents, Multiplication and Division (left-to-right), Addition and Subtraction (left-to-right).');
            });

            // keyboard: Enter on answer to check
            answerInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') checkBtn.click();
            });

            // initialize small sample
            problemEl.textContent = 'Choose options then click Start to generate problems.';
        })();
    </script>
</body>

</html>